/**
 * @license
 * Copyright 2021 Google Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

goog.provide('GoogleSmartCard.LibusbToWebusbAdaptor');

goog.require('GoogleSmartCard.Logging');
goog.require('goog.asserts');
goog.require('goog.log');

goog.scope(function() {

const GSC = GoogleSmartCard;
const LibusbJsDevice = GSC.LibusbProxyDataModel.LibusbJsDevice;
const LibusbJsConfigurationDescriptor =
    GSC.LibusbProxyDataModel.LibusbJsConfigurationDescriptor;
const LibusbJsEndpointType = GSC.LibusbProxyDataModel.LibusbJsEndpointType;
const LibusbJsEndpointDescriptor =
    GSC.LibusbProxyDataModel.LibusbJsEndpointDescriptor;
const LibusbJsDirection = GSC.LibusbProxyDataModel.LibusbJsDirection;
const LibusbJsInterfaceDescriptor =
    GSC.LibusbProxyDataModel.LibusbJsInterfaceDescriptor;

const logger = GSC.Logging.getScopedLogger('LibusbToWebusbAdaptor');

class DeviceState {
  /** @param {!Object} webusbDevice The WebUSB USBDevice object. */
  constructor(webusbDevice) {
    /** @type {!Object} The WebUSB USBDevice object. */
    this.webusbDevice = webusbDevice;
    /** @type {!Set<number>} Active device handles. */
    this.handles = new Set();
    /**
     * @type {!Promise<void>|null} Promise for the ongoing device open request.
     */
    this.openOperationPromise = null;
    /**
     * @type {!Promise<void>|null} Promise for the ongoing device open request.
     */
    this.closeOperationPromise = null;
  }
};

/**
 * Implements the Libusb requests via the WebUSB API.
 */
GSC.LibusbToWebusbAdaptor = class extends GSC.LibusbToJsApiAdaptor {
  constructor() {
    super();
    /**
     * Mapping from IDs (generated by us) into `DeviceState` instances.
     * @type {!Map<number, !DeviceState>}
     */
    this.idToDeviceMap_ = new Map();
    /**
     * The counter that's used for generating new device IDs.
     * @type {number}
     */
    this.nextFreeDeviceId_ = 1;
    /**
     * The counter that's used for generating new device handles.
     * @type {number}
     */
    this.nextFreeDeviceHandle_ = 1;
  }

  /** @override */
  async listDevices() {
    const webusbDevices =
        /** @type {!Array<!Object>} */ (await navigator['usb']['getDevices']());

    // Keep references to all current USBDevice objects, since other WebUSB
    // functions take USBDevice as parameter. It's not possible to
    // programmatically recreate a USBDevice object, so we need to store them.
    this.updateDeviceMap_(webusbDevices);

    return webusbDevices.map(
        webusbDevice => this.convertWebusbDeviceToLibusb_(webusbDevice));
  }

  /** @override */
  async getConfigurations(deviceId) {
    const webusbDevice = this.getDeviceByIdOrThrow_(deviceId).webusbDevice;
    // Note: It's incorrect to check whether the configuration is active by
    // comparing it via "===" against `webusbDevice['configuration']`, because
    // Chrome produces different objects for USBDevice::configuration and for
    // USBDevice::configurations: see crbug.com/1274922. Hence the need to
    // compare by the configurationValue fields.
    const activeConfigurationValue = webusbDevice['configuration'] ?
        webusbDevice['configuration']['configurationValue'] :
        null;
    return webusbDevice['configurations'].map(
        config => getLibusbJsConfigurationDescriptor(
            config, activeConfigurationValue));
  }

  /** @override */
  async openDeviceHandle(deviceId) {
    const deviceState = this.getDeviceByIdOrThrow_(deviceId);
    // WebUSB doesn't have a concept of device handles, so generate a handle
    // from a counter.
    if (deviceState.handles.size === 0) {
      // Ask WebUSB to open the device, but only for the first opened handle.
      // Avoid concurrent WebUSB open()/close() calls, since WebUSB throws on
      // these, hence track the ongoing request's promise in the device state
      // and wait for it.
      if (!deviceState.openOperationPromise) {
        // Note: no "await" here, since we need to set `openOperationPromise`
        // synchronously and therefore let all subsequent requests wait on it.
        deviceState.openOperationPromise = openWebusbDevice(deviceState);
      }
      await deviceState.openOperationPromise;
      deviceState.openOperationPromise = null;
    }
    // WebUSB successfully opened the device. Generate a new handle and return.
    // Note: It's important to update `handles` only after all asynchronous
    // steps are completed, so that concurrent `openDeviceHandle()` calls wait
    // for the promises as well.
    const newHandle = this.nextFreeDeviceHandle_;
    ++this.nextFreeDeviceHandle_;
    deviceState.handles.add(newHandle);
    return newHandle;
  }

  /** @override */
  async closeDeviceHandle(deviceId, deviceHandle) {
    const deviceState = this.getDeviceByIdOrThrow_(deviceId);
    if (!deviceState.handles.has(deviceHandle))
      throw new Error(`Unknown device handle ${deviceHandle}`);
    // Forget the handle (do this synchronously).
    deviceState.handles.delete(deviceHandle);
    if (deviceState.handles.size > 0)
      return;
    // Ask WebUSB to close the device for the last closed handle. Note: the
    // `closeOperationPromise` field is set synchronously, so that subsequent
    // `openDeviceHandle()` calls will wait for it.
    deviceState.closeOperationPromise = deviceState.webusbDevice['close']();
    await deviceState.closeOperationPromise;
    goog.log.fine(logger, 'Successfully closed WebUSB device');
    // On successful completion, clean up the promise. Intentionally leave it
    // set on failures, so that all subsequent `openDeviceHandle()` calls abort.
    deviceState.closeOperationPromise = null;
  }

  /** @override */
  async claimInterface(deviceId, deviceHandle, interfaceNumber) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /** @override */
  async releaseInterface(deviceId, deviceHandle, interfaceNumber) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /** @override */
  async resetDevice(deviceId, deviceHandle) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /** @override */
  async controlTransfer(deviceId, deviceHandle, parameters) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /** @override */
  async bulkTransfer(deviceId, deviceHandle, parameters) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /** @override */
  async interruptTransfer(deviceId, deviceHandle, parameters) {
    // TODO(#429): Implement this method.
    throw new Error('Not implemented');
  }

  /**
   * @private
   * @param {!Object} webusbDevice The USBDevice object.
   * @return {number|null}
   */
  getDeviceId_(webusbDevice) {
    for (const deviceId of this.idToDeviceMap_.keys()) {
      if (this.idToDeviceMap_.get(deviceId).webusbDevice === webusbDevice)
        return deviceId;
    }
    return null;
  }

  /**
   * @private
   * @param {number} deviceId
   * @return {!DeviceState}
   */
  getDeviceByIdOrThrow_(deviceId) {
    const deviceState = this.idToDeviceMap_.get(deviceId);
    if (!deviceState)
      throw new Error(`No device with ID ${deviceId}`);
    return deviceState;
  }

  /**
   * @private
   * @param {!Array<!Object>} webusbDevices The list of USBDevice objects.
   */
  updateDeviceMap_(webusbDevices) {
    /** @type {!Map<number, !DeviceState>} */
    const newIdToDeviceMap = new Map();
    for (const webusbDevice of webusbDevices) {
      let chosenDeviceId = this.getDeviceId_(webusbDevice);
      if (chosenDeviceId === null) {
        // This is a newly appeared device, so generate new ID and state for it.
        chosenDeviceId = this.nextFreeDeviceId_;
        this.nextFreeDeviceId_++;
        newIdToDeviceMap.set(chosenDeviceId, new DeviceState(webusbDevice));
      } else {
        // This is an already tracked device, so reuse its ID and state.
        newIdToDeviceMap.set(
            chosenDeviceId, this.idToDeviceMap_.get(chosenDeviceId));
      }
    }
    // Overwrite the map. Note that this drops the devices that disappeared from
    // the list.
    this.idToDeviceMap_ = newIdToDeviceMap;
  }

  /**
   * @private
   * @param {!Object} webusbDevice
   * @return {!LibusbJsDevice}
   */
  convertWebusbDeviceToLibusb_(webusbDevice) {
    const deviceId = this.getDeviceId_(webusbDevice);
    goog.asserts.assert(deviceId);
    /** @type {!LibusbJsDevice} */
    const libusbJsDevice = {
      'deviceId': deviceId,
      'vendorId': webusbDevice['vendorId'],
      'productId': webusbDevice['productId'],
      'version': (webusbDevice['deviceVersionMajor'] << 8) +
          (webusbDevice['deviceVersionMinor'] << 4) +
          webusbDevice['deviceVersionSubminor'],
    };
    if (webusbDevice['productName'])
      libusbJsDevice['productName'] = webusbDevice['productName'];
    if (webusbDevice['manufacturerName'])
      libusbJsDevice['manufacturerName'] = webusbDevice['manufacturerName'];
    if (webusbDevice['serialNumber'])
      libusbJsDevice['serialNumber'] = webusbDevice['serialNumber'];
    return libusbJsDevice;
  }
};

/**
 * @param {!Object} webusbConfiguration The WebUSB USBConfiguration value.
 * @param {number|null} activeConfigurationValue The active configuration's
 *     value.
 * @return {!LibusbJsConfigurationDescriptor}
 */
function getLibusbJsConfigurationDescriptor(
    webusbConfiguration, activeConfigurationValue) {
  // Note: extraData is skipped, as it's not provided by WebUSB.
  return {
    'active':
        webusbConfiguration['configurationValue'] === activeConfigurationValue,
    'configurationValue': webusbConfiguration['configurationValue'],
    'interfaces': webusbConfiguration['interfaces']
                      .map(
                          webusbInterface =>
                              getLibusbJsInterfaceDescriptor(webusbInterface))
                      .filter(item => item !== null),
  };
}

/**
 * @param {!Object} webusbInterface The WebUSB USBInterface value.
 * @return {!LibusbJsInterfaceDescriptor|null}
 */
function getLibusbJsInterfaceDescriptor(webusbInterface) {
  if (webusbInterface['alternates'].length === 0)
    return null;
  // Note: We're not using the "alternate" field here, since, contrary to the
  // WebUSB specification, Chrome's implementation typically sets this field to
  // null. See crbug.com/1093502.
  const webusbAlternateInterface = webusbInterface['alternates'][0];
  // Note: extraData is skipped, as it's not provided by WebUSB.
  return {
    'interfaceNumber': webusbInterface['interfaceNumber'],
    'interfaceClass': webusbAlternateInterface['interfaceClass'],
    'interfaceSubclass': webusbAlternateInterface['interfaceSubclass'],
    'interfaceProtocol': webusbAlternateInterface['interfaceProtocol'],
    'endpoints': webusbAlternateInterface['endpoints']
                     .map(endpoint => getLibusbJsEndpointDescriptor(endpoint))
                     .filter(item => item !== null),
  };
}

/**
 * @param {!Object} webusbEndpoint The WebUSB USBEndpoint value.
 * @return {!LibusbJsEndpointDescriptor|null}
 */
function getLibusbJsEndpointDescriptor(webusbEndpoint) {
  // According to the USB specification, the endpoint address contains the
  // endpoint number in bits 0..3 and the direction in the bit 7.
  const endpointAddress = webusbEndpoint['endpointNumber'] +
      (webusbEndpoint['direction'] === 'in' ? 1 << 7 : 0);
  const endpointType = getLibusbJsEndpointType(webusbEndpoint['type']);
  if (!endpointType)
    return null;
  // Note: extraData is skipped, as it's not provided by WebUSB.
  return {
    'endpointAddress': endpointAddress,
    'direction': webusbEndpoint['direction'] === 'in' ? LibusbJsDirection.IN :
                                                        LibusbJsDirection.OUT,
    'type': endpointType,
    'maxPacketSize': webusbEndpoint['packetSize'],
  };
}

/**
 * @param {string} webusbEndpointType The WebUSB USBEndpointType value.
 * @return {!LibusbJsEndpointType|null}
 */
function getLibusbJsEndpointType(webusbEndpointType) {
  switch (webusbEndpointType) {
    case 'bulk':
      return LibusbJsEndpointType.BULK;
    case 'interrupt':
      return LibusbJsEndpointType.INTERRUPT;
    case 'isochronous':
      return LibusbJsEndpointType.ISOCHRONOUS;
  }
  // Not emitting a warning or an exception here, since doing that might quickly
  // flood the application's logs.
  return null;
}

/**
 * @param {!DeviceState} deviceState
 * @return {!Promise<void>}
 */
async function openWebusbDevice(deviceState) {
  // First, wait for the ongoing WebUSB close() request if there's any (or
  // fail immediately if the last close() request failed).
  if (deviceState.closeOperationPromise)
    await deviceState.closeOperationPromise;
  // Second, execute the WebUSB open() method.
  await deviceState.webusbDevice['open']();
  goog.log.fine(logger, 'Successfully opened WebUSB device');
}

/**
 * Returns whether the API needed for this adaptor to work is available.
 * @static
 * @return {boolean}
 */
GSC.LibusbToWebusbAdaptor.isApiAvailable = function() {
  return navigator !== undefined && navigator['usb'] !== undefined;
};
});  // goog.scope
