diff --git a/.config b/.config
--- a/.config
+++ b/.config
@@ -1,81 +1,81 @@
 #
 # Automatically generated make config: don't edit
 # ToyBox version: KCONFIG_VERSION
-# Mon Nov 18 07:48:07 2013
+# Fri Jan  3 14:13:06 2014
 #
 CONFIG_TOYBOX_CONTAINER=y
 
 #
 # LSB commands
 #
-CONFIG_DMESG=y
-CONFIG_HOSTNAME=y
-CONFIG_KILLALL=y
-CONFIG_MD5SUM=y
-CONFIG_MD5SUM_SHA1SUM=y
-CONFIG_MKNOD=y
+# CONFIG_DMESG is not set
+# CONFIG_HOSTNAME is not set
+# CONFIG_KILLALL is not set
+# CONFIG_MD5SUM is not set
+# CONFIG_MD5SUM_SHA1SUM is not set
+# CONFIG_MKNOD is not set
 CONFIG_MKTEMP=y
-CONFIG_PASSWD=y
-CONFIG_PIDOF=y
+# CONFIG_PASSWD is not set
+# CONFIG_PIDOF is not set
 CONFIG_SEQ=y
-CONFIG_SYNC=y
-CONFIG_UMOUNT=y
+# CONFIG_SYNC is not set
+# CONFIG_UMOUNT is not set
 
 #
 # Other commands
 #
-CONFIG_ACPI=y
-CONFIG_BLKID=y
+# CONFIG_ACPI is not set
+# CONFIG_BLKID is not set
 CONFIG_BZCAT=y
 CONFIG_CATV=y
-CONFIG_CHROOT=y
-CONFIG_CHVT=y
+# CONFIG_CHROOT is not set
+# CONFIG_CHVT is not set
 CONFIG_CLEAR=y
 CONFIG_COUNT=y
 CONFIG_DOS2UNIX=y
-CONFIG_EJECT=y
+# CONFIG_EJECT is not set
 # CONFIG_FALLOCATE is not set
-CONFIG_FREE=y
+# CONFIG_FREE is not set
 # CONFIG_HELLO is not set
 CONFIG_HELP=y
-CONFIG_INSMOD=y
-CONFIG_LOGIN=y
-CONFIG_LOSETUP=y
-CONFIG_LSMOD=y
-CONFIG_LSUSB=y
-CONFIG_MKSWAP=y
-CONFIG_MODINFO=y
-CONFIG_MOUNTPOINT=y
-CONFIG_NETCAT=y
-CONFIG_NETCAT_LISTEN=y
-CONFIG_ONEIT=y
-CONFIG_PIVOT_ROOT=y
-CONFIG_PMAP=y
+# CONFIG_INSMOD is not set
+# CONFIG_LOGIN is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_LSMOD is not set
+# CONFIG_LSUSB is not set
+# CONFIG_MKSWAP is not set
+# CONFIG_MODINFO is not set
+# CONFIG_MOUNTPOINT is not set
+# CONFIG_NETCAT is not set
+# CONFIG_NETCAT_LISTEN is not set
+# CONFIG_ONEIT is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_PMAP is not set
 CONFIG_PRINTENV=y
 CONFIG_PWDX=y
-CONFIG_READAHEAD=y
-CONFIG_READLINK=y
-CONFIG_REALPATH=y
-CONFIG_REBOOT=y
+# CONFIG_READAHEAD is not set
+# CONFIG_READLINK is not set
+# CONFIG_REALPATH is not set
+# CONFIG_REBOOT is not set
 CONFIG_REV=y
-CONFIG_RMMOD=y
-CONFIG_SETSID=y
-CONFIG_STAT=y
-CONFIG_SWAPOFF=y
-CONFIG_SWAPON=y
-CONFIG_SWITCH_ROOT=y
+# CONFIG_RMMOD is not set
+# CONFIG_SETSID is not set
+# CONFIG_STAT is not set
+# CONFIG_SWAPOFF is not set
+# CONFIG_SWAPON is not set
+# CONFIG_SWITCH_ROOT is not set
 CONFIG_TAC=y
-CONFIG_TASKSET=y
-CONFIG_TIMEOUT=y
+# CONFIG_TASKSET is not set
+# CONFIG_TIMEOUT is not set
 CONFIG_TRUNCATE=y
-CONFIG_UNSHARE=y
-CONFIG_UPTIME=y
+# CONFIG_UNSHARE is not set
+# CONFIG_UPTIME is not set
 CONFIG_USLEEP=y
-CONFIG_VCONFIG=y
-CONFIG_VMSTAT=y
-CONFIG_W=y
+# CONFIG_VCONFIG is not set
+# CONFIG_VMSTAT is not set
+# CONFIG_W is not set
 CONFIG_WHICH=y
-CONFIG_WHOAMI=y
+# CONFIG_WHOAMI is not set
 CONFIG_YES=y
 
 #
@@ -89,10 +89,10 @@ CONFIG_YES=y
 # CONFIG_DUMPLEASES is not set
 # CONFIG_EXPR is not set
 # CONFIG_FDISK is not set
-# CONFIG_FIND is not set
+CONFIG_FIND=y
 # CONFIG_FSCK is not set
 # CONFIG_GROUPADD is not set
-CONFIG_IFCONFIG=y
+# CONFIG_IFCONFIG is not set
 # CONFIG_INIT is not set
 # CONFIG_KLOGD is not set
 # CONFIG_KLOGD_SOURCE_RING_BUFFER is not set
@@ -112,20 +112,20 @@ CONFIG_IFCONFIG=y
 # CONFIG_PGREP is not set
 # CONFIG_PS is not set
 # CONFIG_ROUTE is not set
-# CONFIG_SED is not set
-# CONFIG_SH is not set
-# CONFIG_SH_TTY is not set
-# CONFIG_SH_PROFILE is not set
+CONFIG_SED=y
+CONFIG_SH=y
+CONFIG_SH_TTY=y
+CONFIG_SH_PROFILE=y
 # CONFIG_SH_JOBCTL is not set
 # CONFIG_SH_FLOWCTL is not set
-# CONFIG_SH_QUOTES is not set
-# CONFIG_SH_WILDCARDS is not set
+CONFIG_SH_QUOTES=y
+CONFIG_SH_WILDCARDS=y
 # CONFIG_SH_PROCARGS is not set
-# CONFIG_SH_ENVVARS is not set
-# CONFIG_SH_LOCALS is not set
-# CONFIG_SH_ARRAYS is not set
+CONFIG_SH_ENVVARS=y
+CONFIG_SH_LOCALS=y
+CONFIG_SH_ARRAYS=y
 # CONFIG_SH_PIPES is not set
-# CONFIG_SH_BUILTINS is not set
+CONFIG_SH_BUILTINS=y
 # CONFIG_EXIT is not set
 # CONFIG_CD is not set
 # CONFIG_CD_P is not set
@@ -145,7 +145,7 @@ CONFIG_IFCONFIG=y
 CONFIG_BASENAME=y
 CONFIG_CAL=y
 CONFIG_CAT=y
-CONFIG_CHGRP=y
+# CONFIG_CHGRP is not set
 CONFIG_CHMOD=y
 CONFIG_CKSUM=y
 CONFIG_CMP=y
@@ -155,9 +155,9 @@ CONFIG_CP_MORE=y
 CONFIG_CP_MV=y
 CONFIG_CP_MV_MORE=y
 CONFIG_CUT=y
-CONFIG_DATE=y
-CONFIG_DF=y
-CONFIG_DF_PEDANTIC=y
+# CONFIG_DATE is not set
+# CONFIG_DF is not set
+# CONFIG_DF_PEDANTIC is not set
 CONFIG_DIRNAME=y
 CONFIG_DU=y
 CONFIG_ECHO=y
@@ -166,24 +166,24 @@ CONFIG_EXPAND=y
 CONFIG_FALSE=y
 CONFIG_GREP=y
 CONFIG_HEAD=y
-CONFIG_ID=y
-CONFIG_ID_GROUPS=y
-CONFIG_KILL=y
-CONFIG_LINK=y
+# CONFIG_ID is not set
+# CONFIG_ID_GROUPS is not set
+# CONFIG_KILL is not set
+# CONFIG_LINK is not set
 CONFIG_LN=y
-CONFIG_LOGNAME=y
+# CONFIG_LOGNAME is not set
 CONFIG_LS=y
 CONFIG_LS_COLOR=y
 CONFIG_MKDIR=y
-CONFIG_MKFIFO=y
-CONFIG_NICE=y
+# CONFIG_MKFIFO is not set
+# CONFIG_NICE is not set
 CONFIG_NL=y
-CONFIG_NOHUP=y
+# CONFIG_NOHUP is not set
 CONFIG_OD=y
 CONFIG_PASTE=y
 CONFIG_PATCH=y
 CONFIG_PWD=y
-CONFIG_RENICE=y
+# CONFIG_RENICE is not set
 CONFIG_RM=y
 CONFIG_RMDIR=y
 CONFIG_SLEEP=y
@@ -194,18 +194,18 @@ CONFIG_SORT_FLOAT=y
 CONFIG_SPLIT=y
 CONFIG_TAIL=y
 CONFIG_TAIL_SEEK=y
-CONFIG_TEE=y
-CONFIG_TIME=y
-CONFIG_TOUCH=y
+# CONFIG_TEE is not set
+# CONFIG_TIME is not set
+# CONFIG_TOUCH is not set
 CONFIG_TRUE=y
-CONFIG_TTY=y
+# CONFIG_TTY is not set
 CONFIG_UNAME=y
-CONFIG_UNIQ=y
+# CONFIG_UNIQ is not set
 CONFIG_UNLINK=y
 CONFIG_UUDECODE=y
 CONFIG_UUENCODE=y
 CONFIG_WC=y
-CONFIG_WHO=y
+# CONFIG_WHO is not set
 CONFIG_XARGS=y
 # CONFIG_XARGS_PEDANTIC is not set
 
@@ -222,5 +222,5 @@ CONFIG_TOYBOX_FLOAT=y
 CONFIG_TOYBOX_HELP=y
 CONFIG_TOYBOX_HELP_DASHDASH=y
 CONFIG_TOYBOX_I18N=y
-# CONFIG_TOYBOX_FREE is not set
+CONFIG_TOYBOX_FREE=y
 # CONFIG_TOYBOX_DEBUG is not set
diff --git a/configure b/configure
--- a/configure
+++ b/configure
@@ -8,7 +8,7 @@
 # Required for our expected ABI. we're 8-bit clean thus "char" must be unsigned.
 CFLAGS="$CFLAGS -funsigned-char"
 
-[ -z "$OPTIMIZE" ] && OPTIMIZE="-Os -ffunction-sections -fdata-sections -Wl,--gc-sections -fno-asynchronous-unwind-tables"
+[ -z "$OPTIMIZE" ] && OPTIMIZE="-ffunction-sections -fdata-sections -fno-asynchronous-unwind-tables"
 [ -z "$CC" ] && CC=cc
 [ -z "$STRIP" ] && STRIP=strip
 
diff --git a/lib/getmountlist.c b/lib/getmountlist.c
--- a/lib/getmountlist.c
+++ b/lib/getmountlist.c
@@ -5,13 +5,18 @@
 
 #include "toys.h"
 
+#ifndef __native_client__
 #include <mntent.h>
+#endif
 
 // Get list of mounted filesystems, including stat and statvfs info.
 // Returns a reversed list, which is good for finding overmounts and such.
 
 struct mtab_list *xgetmountlist(char *path)
 {
+#ifdef __native_client__
+  perror_exit("can't obtain mountlist on native client");
+#else
   struct mtab_list *mtlist, *mt;
   struct mntent *me;
   FILE *fp;
@@ -40,4 +45,5 @@ struct mtab_list *xgetmountlist(char *path)
   endmntent(fp);
 
   return mtlist;
+#endif
 }
diff --git a/lib/lib.h b/lib/lib.h
--- a/lib/lib.h
+++ b/lib/lib.h
@@ -151,6 +151,7 @@ int yesno(char *prompt, int def);
 // net.c
 int xsocket(int domain, int type, int protocol);
 
+#ifndef __native_client__
 // getmountlist.c
 struct mtab_list {
   struct mtab_list *next;
@@ -160,6 +161,7 @@ struct mtab_list {
   char *device;
   char type[0];
 };
+#endif
 
 struct mtab_list *xgetmountlist(char *path);
 
diff --git a/lib/password.c b/lib/password.c
--- a/lib/password.c
+++ b/lib/password.c
@@ -7,6 +7,10 @@
 #include "xregcomp.h"
 #include <time.h>
 
+#ifdef __native_client__
+#define LOGIN_NAME_MAX 256
+#endif
+
 int get_salt(char *salt, char *algo)
 {      
   int i, len = 0, offset = 0;
diff --git a/lib/pending.c b/lib/pending.c
--- a/lib/pending.c
+++ b/lib/pending.c
@@ -57,7 +57,7 @@ void daemonize(void)
   if (pid < 0) perror_exit("DAEMON: failed to fork");
   if (pid) exit(EXIT_SUCCESS);
 
-  setsid();
+  //setsid();
   dup2(fd, 0);
   dup2(fd, 1);
   dup2(fd, 2);
diff --git a/lib/portability.c b/lib/portability.c
--- a/lib/portability.c
+++ b/lib/portability.c
@@ -6,7 +6,7 @@
 
 #include "toys.h"
 
-#if defined(__APPLE__) || defined(__ANDROID__)
+#if defined(__APPLE__) || defined(__ANDROID__) || defined(__native_client__)
 ssize_t getdelim(char **linep, size_t *np, int delim, FILE *stream)
 {
   int ch;
@@ -61,7 +61,7 @@ ssize_t getline(char **linep, size_t *np, FILE *stream)
 }
 #endif
 
-#if defined(__APPLE__)
+#if defined(__APPLE__) || defined(__native_client__)
 extern char **environ;
 
 int clearenv(void)
@@ -70,3 +70,156 @@ int clearenv(void)
   return 0;
 }
 #endif
+
+#if defined(__native_client__)
+#ifndef AT_FDCWD
+/* Laster headers include openat() declaration but not the others */
+int openat(int dirfd, const char *pathname, int flags, ...)
+  __attribute__((weak));
+#endif
+int fstatat(int dirfd, const char *pathname, struct stat *buf, int flags)
+  __attribute__((weak));
+int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags)
+  __attribute__((weak));
+int readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz)
+  __attribute__((weak));
+int unlinkat(int dirfd, const char *pathname, int flags)
+  __attribute__((weak));
+int faccessat(int dirfd, const char *pathname, int mode, int flags)
+  __attribute__((weak));
+DIR *fdopendir(int dirfd)
+  __attribute__((weak));
+
+int mkdirat(int dirfd, const char *pathname, mode_t mode)
+  __attribute__((weak));
+int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev)
+  __attribute__((weak));
+int fchownat(int dirfd, const char *pathname, uid_t owner,
+    gid_t group, int flags)
+  __attribute__((weak));
+int symlinkat(const char *oldpath, int dirfd, const char *newpath)
+  __attribute__((weak));
+int linkat(int dirfd, const char *oldpath,
+    int newdirfd, const char *newpath, int flags)
+  __attribute__((weak));
+
+#define _AT_WRAP_START(A) \
+    int fchdir_err = 0; \
+    char *save = xgetcwd(); \
+    if (!save) perror_exit("fd_wrapper_"A); \
+    if (dirfd != AT_FDCWD) fchdir_err = fchdir(dirfd);
+
+#define _AT_WRAP_END(A) \
+    if (dirfd != AT_FDCWD) chdir(save); \
+    free(save);
+
+int openat(int dirfd, const char *pathname, int flags, ...) {
+  _AT_WRAP_START("openat")
+  int fd = open(pathname, flags);
+  _AT_WRAP_END("openat")
+  return fd;
+}
+
+int fstatat(int dirfd, const char *pathname, struct stat *buf, int flags) {
+  // We are going to ignore flags here.
+  //if (flags) perror_exit("fstatat_flags");
+  _AT_WRAP_START("fstatat")
+  int result;
+  if (flags & AT_SYMLINK_NOFOLLOW)
+    result = lstat(pathname, buf);
+  else
+    result = stat(pathname, buf);
+  _AT_WRAP_END("fstatat")
+  return result;
+}
+
+int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags) {
+  // We are going to ignore flags here.
+  //if (flags) perror_exit("fchmodat_flags");
+  _AT_WRAP_START("fchmodat")
+  int result = chmod(pathname, mode);
+  _AT_WRAP_END("fchmodat")
+  return result;
+}
+
+int readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz) {
+  _AT_WRAP_START("readlinkat")
+  int result = readlink(pathname, buf, bufsiz);
+  _AT_WRAP_END("readlinkat")
+  return result;
+}
+
+int unlinkat(int dirfd, const char *pathname, int flags) {
+  // We are going to ignore flags here.
+  //if (flags) perror_exit("unlinkat_flags");
+  _AT_WRAP_START("unlinkat")
+  int result;
+  if(flags & AT_REMOVEDIR) {
+    result = rmdir(pathname);
+  } else {
+    result = unlink(pathname);
+  }
+  _AT_WRAP_END("unlinkat")
+  return result;
+}
+
+int faccessat(int dirfd, const char *pathname, int mode, int flags) {
+  //if (flags) perror_exit("faccessat_flags");
+  _AT_WRAP_START("faccessat")
+  int result = access(pathname, mode);
+  _AT_WRAP_END("faccessat")
+  return result;
+}
+
+DIR *fdopendir(int dirfd) {
+  _AT_WRAP_START("fdopendir")
+  DIR *dir;
+  if (fchdir_err) {
+    perror("fdopendir: ");
+  } 
+  dir = opendir(".");
+  _AT_WRAP_END("fdopendir")
+  return dir;
+}
+
+int mkdirat(int dirfd, const char *pathname, mode_t mode) {
+  _AT_WRAP_START("mkdirat")
+  int result = mkdir(pathname, mode);
+  _AT_WRAP_END("mkdirat")
+  return result;
+}
+
+int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev) {
+  error_exit("mknod not supported");
+}
+
+int fchownat(int dirfd, const char *pathname, uid_t owner,
+    gid_t group, int flags) {
+  _AT_WRAP_START("fchownat")
+  int result = chown(pathname, owner, group);
+  _AT_WRAP_END("fchownat")
+  return result;
+}
+
+int symlinkat(const char *oldpath, int dirfd, const char *newpath) {
+  _AT_WRAP_START("symlinkat")
+  int result = symlink(oldpath, newpath);
+  _AT_WRAP_END("symlinkat")
+  return result;
+}
+
+int linkat(int olddirfd, const char *oldpath,
+    int newdirfd, const char *newpath, int flags) {
+  int result;
+  if ((oldpath[0] == '/') && (newpath[0] == '/')) {
+    result = link(oldpath, newpath);
+  } else {
+    errno = EINVAL;
+    result = -1;
+  }
+  // We do not support double linking.
+  return result;
+}
+
+
+#endif
diff --git a/lib/portability.h b/lib/portability.h
--- a/lib/portability.h
+++ b/lib/portability.h
@@ -15,7 +15,7 @@
 
 // Test for gcc (using compiler builtin #define)
 
-#ifdef __GNUC__
+#if defined(__GNUC__) && !defined(__native_client__)
 #define noreturn	__attribute__((noreturn))
 #else
 #define noreturn
@@ -26,7 +26,16 @@
 
 // This isn't in the spec, but it's how we determine what libc we're using.
 
+// Include sys/types.h so that we can later check for _NEWLIB_VERSION.
+#if defined(__native_client__)
+#include <sys/types.h>
+#endif
+
+#if defined(__native_client__) && defined(_NEWLIB_VERSION)
+#include <sys/features.h>
+#else
 #include <features.h>
+#endif
 
 // Various constants old build environments might not have even if kernel does
 
@@ -68,7 +77,7 @@ char *strptime(const char *buf, const char *format, struct tm *tm);
 ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
 
 // When building under obsolete glibc (Ubuntu 8.04-ish), hold its hand a bit.
-#elif __GLIBC__ == 2 && __GLIBC_MINOR__ < 10
+#elif __GLIBC__ == 2 && __GLIBC_MINOR__ < 10 && !defined(__native_client__)
 #define fstatat fstatat64
 int fstatat64(int dirfd, const char *pathname, void *buf, int flags);
 int readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz);
@@ -102,7 +111,7 @@ int utimensat(int fd, const char *path, const struct timespec times[2], int flag
 
 // Work out how to do endianness
 
-#ifndef __APPLE__
+#if !defined(__APPLE__) && !defined(__native_client__)
 #include <byteswap.h>
 #include <endian.h>
 
diff --git a/lib/xwrap.c b/lib/xwrap.c
--- a/lib/xwrap.c
+++ b/lib/xwrap.c
@@ -224,7 +224,8 @@ off_t xlseek(int fd, off_t offset, int whence)
 
 char *xgetcwd(void)
 {
-  char *buf = getcwd(NULL, 0);
+  char *buf = xmalloc(sizeof(char) * (PATH_MAX+1));
+  buf = getcwd(buf, PATH_MAX+1);
   if (!buf) perror_exit("xgetcwd");
 
   return buf;
@@ -353,7 +354,11 @@ error:
 // Resolve all symlinks, returning malloc() memory.
 char *xrealpath(char *path)
 {
+#ifdef __native_client__
+  char *new = strdup(path);
+#else
   char *new = realpath(path, NULL);
+#endif
   if (!new) perror_exit("realpath '%s'", path);
   return new;
 }
diff --git a/scripts/install.c b/scripts/install.c
--- a/scripts/install.c
+++ b/scripts/install.c
@@ -3,6 +3,9 @@
  * Copyright 2006 Rob Landley <rob@landley.net>
  */
 
+#define _SKIP_LIBC_HEADERS
+#include <setjmp.h>
+#include <stdio.h>
 #include "toys.h"
 
 #undef NEWTOY
diff --git a/scripts/make.sh b/scripts/make.sh
--- a/scripts/make.sh
+++ b/scripts/make.sh
@@ -162,9 +162,11 @@ echo "Library probe..."
 # that doesn't exist, so we have to detect and skip nonexistent libraries
 # for it.
 
-OPTLIBS="$(for i in util crypt m; do echo "int main(int argc, char *argv[]) {return 0;}" | ${CROSS_COMPILE}${CC} -xc - -o /dev/null -Wl,--as-needed -l$i > /dev/null 2>/dev/null && echo -l$i; done)"
+OPTLIBS="$(for i in glibc-compat nacl_io util crypt m; do echo "int main(int argc, char *argv[]) {return 0;}" | ${CROSS_COMPILE}${CC} -xc - -o /dev/null -Wl,--as-needed -l$i > /dev/null 2>/dev/null && echo -l$i; done)"
 
 echo "Compile toybox..."
+OPTLIBS="${LDFLAGS}"
+echo $OPTLIBS
 
 do_loudly()
 {
diff --git a/toys.h b/toys.h
--- a/toys.h
+++ b/toys.h
@@ -5,6 +5,8 @@
 
 #include "generated/config.h"
 
+#ifndef _SKIP_LIBC_HEADERS
+
 #include "lib/portability.h"
 
 #include <ctype.h>
@@ -16,12 +18,16 @@
 #include <limits.h>
 #include <libgen.h>
 #include <math.h>
+#ifndef __native_client__
 #include <pty.h>
+#endif
 #include <pwd.h>
 #include <sched.h>
 #include <setjmp.h>
 #include <sched.h>
+#ifndef __native_client__
 #include <shadow.h>
+#endif
 #include <stdarg.h>
 #include <stddef.h>
 #include <stdint.h>
@@ -34,10 +40,13 @@
 #include <sys/mount.h>
 #include <sys/resource.h>
 #include <sys/stat.h>
+#ifndef __native_client__
 #include <sys/statfs.h>
 #include <sys/statvfs.h>
 #include <sys/sysinfo.h>
 #include <sys/swap.h>
+#endif
+#include <sys/termios.h>
 #include <sys/time.h>
 #include <sys/times.h>
 #include <sys/types.h>
@@ -47,7 +56,9 @@
 #include <time.h>
 #include <unistd.h>
 #include <utime.h>
+#ifndef __native_client__
 #include <utmpx.h>
+#endif
 
 // Internationalization support
 
@@ -59,7 +70,9 @@
 
 #include <arpa/inet.h>
 #include <netdb.h>
+#ifndef __native_client__
 #include <net/if.h>
+#endif
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <poll.h>
@@ -69,6 +82,8 @@
 #include "lib/lib.h"
 #include "toys/e2fs.h"
 
+#endif // _SKIP_LIBC_HEADERS
+
 // Get list of function prototypes for all enabled command_main() functions.
 
 #define NEWTOY(name, opts, flags) void name##_main(void);
@@ -76,7 +91,9 @@
 #include "generated/newtoys.h"
 #include "generated/oldtoys.h"
 #include "generated/flags.h"
+#ifndef _SKIP_LIBC_HEADERS
 #include "generated/globals.h"
+#endif
 
 // These live in main.c
 
diff --git a/toys/other/stat.c b/toys/other/stat.c
--- a/toys/other/stat.c
+++ b/toys/other/stat.c
@@ -40,7 +40,9 @@ GLOBALS(
 
   union {
     struct stat st;
+#ifndef __native_client__
     struct statfs sf;
+#endif
   } stat;
   struct passwd *user_name;
   struct group *group_name;
diff --git a/toys/other/timeout.c b/toys/other/timeout.c
--- a/toys/other/timeout.c
+++ b/toys/other/timeout.c
@@ -33,7 +33,9 @@ GLOBALS(
   int nextsig;
   pid_t pid;
   struct timeval ktv;
+#ifndef __native_client__
   struct itimerval itv;
+#endif
 )
 
 static void handler(int i)
diff --git a/toys/pending/sh.c b/toys/pending/sh.c
--- a/toys/pending/sh.c
+++ b/toys/pending/sh.c
@@ -177,6 +177,10 @@ config CD_P
 #define FOR_sh
 #include "toys.h"
 
+#if defined(__native_client__)
+# include <spawn.h>
+#endif
+
 GLOBALS(
   char *command;
 )
@@ -291,7 +295,11 @@ static void run_pipeline(struct pipeline *line)
 
   tl = toy_find(cmd->argv[0]);
   // Is this command a builtin that should run in this process?
+#ifdef __native_client__
+  if (tl) {
+#else
   if (tl && (tl->flags & TOYFLAG_NOFORK)) {
+#endif
     struct toy_context temp;
     jmp_buf rebound;
 
@@ -311,10 +319,15 @@ static void run_pipeline(struct pipeline *line)
   } else {
     int status;
 
+#ifdef __native_client__
+    cmd->pid = spawnve(P_NOWAIT, cmd->argv[0], cmd->argv, NULL);
+    if (cmd->pid <= 0) xprintf("error spawning %s\n", cmd->argv[0]);
+    else waitpid(cmd->pid, &status, 0);
+#else
     cmd->pid = vfork();
     if (!cmd->pid) xexec(cmd->argv);
     else waitpid(cmd->pid, &status, 0);
-
+#endif
     if (CFG_SH_FLOWCTL || CFG_SH_PIPES) {
       if (WIFEXITED(status)) cmd->pid = WEXITSTATUS(status);
       if (WIFSIGNALED(status)) cmd->pid = WTERMSIG(status);
@@ -382,7 +395,12 @@ void sh_main(void)
     for (;;) {
       char *command = 0;
       if (!f) xputc('$');
-      if (1 > getline(&command, &cmdlen, f ? f : stdin)) break;
+      if (1 > getline(&command, &cmdlen, f ? f : stdin)) 
+#ifdef __native_client__ // Here we want to continue cycling until explicit exit.
+        continue;
+#else
+        break;
+#endif
       handle(command);
       free(command);
     }
diff --git a/toys/posix/cp.c b/toys/posix/cp.c
--- a/toys/posix/cp.c
+++ b/toys/posix/cp.c
@@ -232,18 +232,24 @@ int cp_node(struct dirtree *try)
 
       // Inability to set these isn't fatal, some require root access.
 
+#ifndef __native_client__
       times[0] = try->st.st_atim;
       times[1] = try->st.st_mtim;
+#endif
 
       // If we can't get a filehandle to the actual object, use racy functions
       if (fdout == AT_FDCWD) {
         fchownat(cfd, catch, try->st.st_uid, try->st.st_gid,
                  AT_SYMLINK_NOFOLLOW);
+#ifndef __native_client__
         utimensat(cfd, catch, times, AT_SYMLINK_NOFOLLOW);
+#endif
         // permission bits already correct for mknod, don't apply to symlink
       } else {
         fchown(fdout, try->st.st_uid, try->st.st_gid);
+#ifndef __native_client__
         futimens(fdout, times);
+#endif
         fchmod(fdout, try->st.st_mode);
       }
     }
diff --git a/toys/posix/ls.c b/toys/posix/ls.c
--- a/toys/posix/ls.c
+++ b/toys/posix/ls.c
@@ -97,10 +97,15 @@ static char *getusername(uid_t uid)
 
 static char *getgroupname(gid_t gid)
 {
+#ifdef __native_client__
+  static char* gr_name = "nacl";
+  return gr_name;
+#else
   struct group *gr = getgrgid(gid);
 
   sprintf(TT.gid_buf, "%u", (unsigned)gid);
   return gr ? gr->gr_name : TT.gid_buf;
+#endif
 }
 
 // Figure out size of printable entry fields for display indent/wrap
