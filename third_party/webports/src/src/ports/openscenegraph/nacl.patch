diff --git a/Makefile b/Makefile
new file mode 100644
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,17 @@
+export CXXFLAGS += -O3
+
+.PHONY: all clean
+
+NACLPORTS_INCLUDE = ../../../toolchain/$(OS_PREFIX)_x86/nacl/usr/include
+
+all:
+	cd src/osg && $(MAKE) all
+	cd src/osgUtil && $(MAKE) all
+	cd src/OpenThreads && $(MAKE) all
+
+clean:
+	@echo Make clean
+	rm -f *.a
+	cd src/osg && $(MAKE) clean
+	cd src/osgUtil && $(MAKE) clean
+	cd src/OpenThreads && $(MAKE) clean
diff --git a/include/OpenThreads/Config b/include/OpenThreads/Config
new file mode 100644
--- /dev/null
+++ b/include/OpenThreads/Config
@@ -0,0 +1,42 @@
+/* -*-c++-*- OpenSceneGraph - Copyright (C) 2008 Robert Osfield 
+ *
+ * This library is open source and may be redistributed and/or modified under  
+ * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
+ * (at your option) any later version.  The full license is in LICENSE file
+ * included with this distribution, and on the openscenegraph.org website.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * OpenSceneGraph Public License for more details.
+*/
+
+/****************************************************************************
+ * THIS FILE IS AUTOGENERATED BY CMAKE. DO NOT EDIT!
+ ****************************************************************************/
+
+/* Changes to the configuration reflected here can be made with ccmake on
+ * unix or with cmake-gui on windows. Alternatively you can use cmake's -D
+ * or -P switches to set some configuration values at cmake configuration time.
+ */
+
+#ifndef _OPENTHREADS_CONFIG
+#define _OPENTHREADS_CONFIG
+
+#ifdef __linux__
+#define _OPENTHREADS_ATOMIC_USE_GCC_BUILTINS
+#endif  // __linux__
+
+/* #undef _OPENTHREADS_ATOMIC_USE_MIPOSPRO_BUILTINS */
+/* #undef _OPENTHREADS_ATOMIC_USE_SUN */
+
+#ifdef WIN32
+#define _OPENTHREADS_ATOMIC_USE_WIN32_INTERLOCKED
+#endif  // WIN32
+
+/* #undef _OPENTHREADS_ATOMIC_USE_BSD_ATOMIC */
+/* #undef _OPENTHREADS_ATOMIC_USE_MUTEX */
+
+#define OT_LIBRARY_STATIC
+
+#endif
diff --git a/include/osg/Array b/include/osg/Array
--- a/include/osg/Array
+++ b/include/osg/Array
@@ -154,7 +154,7 @@ class TemplateArray : public Array, public MixinVector<T>
         TemplateArray& operator = (const TemplateArray& array)
         {
             if (this==&array) return *this;
-            assign(array.begin(),array.end());
+            this->assign(array.begin(),array.end());
             return *this;
         } 
 
@@ -240,7 +240,7 @@ class TemplateIndexArray : public IndexArray, public MixinVector<T>
         TemplateIndexArray& operator = (const TemplateIndexArray& array)
         {
             if (this==&array) return *this;
-            assign(array.begin(),array.end());
+            this->assign(array.begin(),array.end());
             return *this;
         } 
 
diff --git a/include/osg/Config b/include/osg/Config
new file mode 100644
--- /dev/null
+++ b/include/osg/Config
@@ -0,0 +1,48 @@
+/* -*-c++-*- OpenSceneGraph - Copyright (C) 2008-2009 Robert Osfield
+ *
+ * This library is open source and may be redistributed and/or modified under  
+ * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or 
+ * (at your option) any later version.  The full license is in LICENSE file
+ * included with this distribution, and on the openscenegraph.org website.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
+ * OpenSceneGraph Public License for more details.
+*/
+
+/****************************************************************************
+ * THIS FILE IS AUTOGENERATED BY CMAKE. DO NOT EDIT!
+ ****************************************************************************/
+
+/* Changes to the configuration reflected here can be made with ccmake on
+ * unix or with cmake-gui on windows. Alternatively you can use cmake's -D
+ * or -P switches to set some configuration values at cmake configuration time.
+ */
+
+#ifndef OSG_CONFIG
+#define OSG_CONFIG 1
+
+/* #undef OSG_NOTIFY_DISABLED */
+#define OSG_USE_FLOAT_MATRIX
+#define OSG_USE_FLOAT_PLANE
+#define OSG_USE_FLOAT_BOUNDINGSPHERE
+#define OSG_USE_FLOAT_BOUNDINGBOX
+#define OSG_USE_REF_PTR_IMPLICIT_OUTPUT_CONVERSION
+/* #undef OSG_USE_UTF8_FILENAME */
+#define OSG_DISABLE_MSVC_WARNINGS
+
+/* #undef OSG_GLU_AVAILABLE */
+/* #undef OSG_GL1_AVAILABLE */
+/* #undef OSG_GL2_AVAILABLE */
+/* #undef OSG_GL3_AVAILABLE */
+/* #undef OSG_GLES1_AVAILABLE */
+#define OSG_GLES2_AVAILABLE
+#define OSG_GL_LIBRARY_STATIC
+/* #undef OSG_GL_DISPLAYLISTS_AVAILABLE */
+/* #undef OSG_GL_MATRICES_AVAILABLE */
+/* #undef OSG_GL_VERTEX_FUNCS_AVAILABLE */
+/* #undef OSG_GL_VERTEX_ARRAY_FUNCS_AVAILABLE */
+/* #undef OSG_GL_FIXED_FUNCTION_AVAILABLE */
+
+#endif
diff --git a/include/osg/Math b/include/osg/Math
--- a/include/osg/Math
+++ b/include/osg/Math
@@ -211,9 +211,19 @@ inline double round(double v) { return v>=0.0?floor(v+0.5):ceil(v-0.5); }
         inline bool isNaN(float v) { return std::isnan(v); }
         inline bool isNaN(double v) { return std::isnan(v); }
     #else
-        // Need to use to std::isnan to avoid undef problem from <cmath>
-        inline bool isNaN(float v) { return isnan(v); }
-        inline bool isNaN(double v) { return isnan(v); }
+        #if defined(__native_client__)
+            #if defined(_GLIBCXX_HAVE_ISNAN) || defined(isnan)
+                inline bool isNaN(float v) { return isnan(v); }
+                inline bool isNaN(double v) { return isnan(v); }
+            #else
+                inline bool isNaN(float v) { return std::isnan(v); }
+                inline bool isNaN(double v) { return std::isnan(v); }
+            #endif
+        #else
+            // Need to use to std::isnan to avoid undef problem from <cmath>
+            inline bool isNaN(float v) { return isnan(v); }
+            inline bool isNaN(double v) { return isnan(v); }
+        #endif
     #endif
 #endif
 
diff --git a/src/OpenThreads/Makefile b/src/OpenThreads/Makefile
new file mode 100644
--- /dev/null
+++ b/src/OpenThreads/Makefile
@@ -0,0 +1,43 @@
+OSG_ROOT = ../..
+
+INCLUDE = -I$(OSG_ROOT)/include
+
+NACL_PORTS_PREFIX = ../../../../../toolchain/$(OS_PREFIX)_x86/nacl/usr
+
+NACLPORTS_INCLUDE = $(NACL_PORTS_PREFIX)/include
+
+NACLPORTS_LIBDIR = $(NACL_PORTS_PREFIX)/lib
+
+INCLUDE = -I$(OSG_ROOT)/include
+
+COMMON_OBJ_FILES = \
+		common/Atomic.o \
+		common/Version.o
+
+PTHREADS_OBJ_FILES = \
+		pthreads/PThread.o \
+		pthreads/PThreadBarrier.o \
+		pthreads/PThreadCondition.o \
+		pthreads/PThreadMutex.o
+
+OBJ_DIR = obj
+
+all: $(LIB_OPENTHREADS)
+	@echo "Making libOpenThreads"
+
+clean:
+	rm -rf $(OBJ_DIR) $(LIB_OPENTHREADS)
+
+$(OBJ_DIR):
+	mkdir $(OBJ_DIR)
+	mkdir $(OBJ_DIR)/common
+	mkdir $(OBJ_DIR)/pthreads
+
+$(COMMON_OBJ_FILES): %.o: %.cpp $(OBJ_DIR)
+	$(CXX) -c $(INCLUDE) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@
+
+$(PTHREADS_OBJ_FILES): %.o: %.c++ $(OBJ_DIR)
+	$(CXX) -c $(INCLUDE) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@
+
+$(LIB_OPENTHREADS): $(OBJ_DIR) $(COMMON_OBJ_FILES) $(PTHREADS_OBJ_FILES)
+	cd $(OBJ_DIR) && $(AR) rcs ../$(OSG_ROOT)/$(LIB_OPENTHREADS) $(COMMON_OBJ_FILES) $(PTHREADS_OBJ_FILES)
diff --git a/src/OpenThreads/common/Version.in b/src/OpenThreads/common/Version.in
new file mode 100644
--- /dev/null
+++ b/src/OpenThreads/common/Version.in
@@ -0,0 +1,38 @@
+/* -*-c++-*- OpenThreads library, Copyright (C) 2002 - 2007  The Open Thread Group
+ *
+ * This library is open source and may be redistributed and/or modified under
+ * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
+ * (at your option) any later version.  The full license is in LICENSE file
+ * included with this distribution, and on the openscenegraph.org website.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * OpenSceneGraph Public License for more details.
+*/
+
+#ifndef OPENTHREADS_VERSION
+#define OPENTHREADS_VERSION 1
+
+#include <OpenThreads/Exports>
+
+extern "C" {
+
+#define OPENTHREADS_MAJOR_VERSION @OPENTHREADS_MAJOR_VERSION@
+#define OPENTHREADS_MINOR_VERSION @OPENTHREADS_MINOR_VERSION@
+#define OPENTHREADS_PATCH_VERSION @OPENTHREADS_PATCH_VERSION@
+#define OPENTHREADS_SOVERSION @OPENTHREADS_SOVERSION@
+
+/** OpenThreadsGetVersion() returns the library version number.
+ * Numbering convention : OpenThreads-1.0 will return 1.0 from OpenThreadsGetVersion. */
+extern OPENTHREAD_EXPORT_DIRECTIVE const char* OpenThreadsGetVersion();
+
+/** The OpenThreadsGetSOVersion() method returns the OpenSceneGraph soversion number. */
+extern OPENTHREAD_EXPORT_DIRECTIVE const char* OpenThreadsGetSOVersion();
+
+/** The OpenThreadsGetLibraryName() method returns the library name in human-friendly form. */
+extern OPENTHREAD_EXPORT_DIRECTIVE const char* OpenThreadsGetLibraryName();
+
+}
+
+#endif
diff --git a/src/OpenThreads/pthreads/PThread.c++ b/src/OpenThreads/pthreads/PThread.c++
--- a/src/OpenThreads/pthreads/PThread.c++
+++ b/src/OpenThreads/pthreads/PThread.c++
@@ -45,6 +45,7 @@
 #endif
 
 #include <OpenThreads/Thread>
+#include "PThreadCleanup.h"
 #include "PThreadPrivateData.h"
 
 #include <iostream>
@@ -149,7 +150,7 @@ private:
             printf("Error: pthread_setspecific(,) returned error status, status = %d\n",status);
         }
 
-    pthread_cleanup_push(thread_cleanup_handler, &tcs);
+    PThreadCleanup thread_cleanup(thread_cleanup_handler, &tcs);
 
 #ifdef ALLOW_PRIORITY_SCHEDULING
 
@@ -169,7 +170,7 @@ private:
 
         pd->isRunning = false;
 
-    pthread_cleanup_pop(0);
+    thread_cleanup.Reset(0);
 
         return 0;
 
@@ -387,6 +388,7 @@ Thread::Thread() {
     pd->threadPriority = Thread::THREAD_PRIORITY_DEFAULT;
     pd->threadPolicy = Thread::THREAD_SCHEDULE_DEFAULT;
     pd->cpunum = -1;
+    pd->isCanceledMutex = new Mutex(Mutex::MUTEX_RECURSIVE);
 
     _prvData = static_cast<void *>(pd);
 
@@ -412,6 +414,7 @@ Thread::~Thread()
     cancel();
     }
 
+    delete pd->isCanceledMutex;
     delete pd;
     
     _prvData = 0;
@@ -693,14 +696,16 @@ int Thread::join() {
 //
 int Thread::testCancel() {
 
+    int rv = 0;
     PThreadPrivateData *pd = static_cast<PThreadPrivateData *> (_prvData);
-
-    if(pthread_self() != pd->tid)
-    return -1;
-
-    pthread_testcancel();
-
-    return 0;
+    if (pd->isRunning)
+    {
+        pd->isCanceledMutex->lock();
+        if (pd->isCanceled)
+          rv = 1;
+        pd->isCanceledMutex->unlock();
+    }
+    return rv;
 
 }
 
@@ -716,56 +721,15 @@ int Thread::cancel() {
     PThreadPrivateData *pd = static_cast<PThreadPrivateData *> (_prvData);
     if (pd->isRunning)
     {
+        pd->isCanceledMutex->lock();
         pd->isCanceled = true;
-        int status = pthread_cancel(pd->tid);
-        return status;
+        pd->isCanceledMutex->unlock();
     }
     return 0;
 }
 
 //-----------------------------------------------------------------------------
 //
-// Description: Disable cancelibility
-//
-// Use: public
-//
-int Thread::setCancelModeDisable() {
-
-    return pthread_setcancelstate( PTHREAD_CANCEL_DISABLE, 0 );
-
-}
-
-//-----------------------------------------------------------------------------
-//
-// Description: set the thread to cancel immediately
-//
-// Use: public
-//
-int Thread::setCancelModeAsynchronous() {
-
-    int status = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, 0);
-    if(status != 0) return status;
-
-    return pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, 0);
-}
-
-//-----------------------------------------------------------------------------
-//
-// Description: set the thread to cancel at the next convienent point.
-//
-// Use: public
-//
-int Thread::setCancelModeDeferred() {
-
-    int status = pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, 0);
-    if(status != 0) return status;
-
-    return pthread_setcancelstate( PTHREAD_CANCEL_ENABLE, 0);
-
-}
-
-//-----------------------------------------------------------------------------
-//
 // Description: Set the thread's schedule priority (if able)
 //
 // Use: public
@@ -910,7 +874,7 @@ int Thread::YieldCurrentThread()
 //
 int Thread::microSleep(unsigned int microsec)
 {
-    return ::usleep(microsec);
+    return ::sleep(microsec);
 }
 
 
diff --git a/src/OpenThreads/pthreads/PThreadBarrier.c++ b/src/OpenThreads/pthreads/PThreadBarrier.c++
--- a/src/OpenThreads/pthreads/PThreadBarrier.c++
+++ b/src/OpenThreads/pthreads/PThreadBarrier.c++
@@ -21,6 +21,7 @@
 #include <unistd.h>
 #include <OpenThreads/Barrier>
 #include "PThreadBarrierPrivateData.h"
+#include "PThreadCleanup.h"
 
 using namespace OpenThreads;
 
@@ -178,11 +179,11 @@ void Barrier::block(unsigned int numThreads) {
         {
             while (pd->phase == my_phase)
             {
-                pthread_cleanup_push(barrier_cleanup_handler, &(pd->lock));
+                PThreadCleanup thread_cleanup(barrier_cleanup_handler, &(pd->lock));
 
                 pthread_cond_wait(&(pd->cond), &(pd->lock));
 
-                pthread_cleanup_pop(0);
+                thread_cleanup.Reset(0);
             }
         }
     }
diff --git a/src/OpenThreads/pthreads/PThreadCleanup.h b/src/OpenThreads/pthreads/PThreadCleanup.h
new file mode 100644
--- /dev/null
+++ b/src/OpenThreads/pthreads/PThreadCleanup.h
@@ -0,0 +1,28 @@
+#ifndef _PTHREADCLEANUP_H_
+#define _PTHREADCLEANUP_H_
+namespace OpenThreads {
+class PThreadCleanup {
+ public:
+  typedef void (*CleanupHandler)(void*);
+
+  PThreadCleanup(CleanupHandler handler, void* arg)
+    : handler_(handler), arg_(arg) {
+  }
+  ~PThreadCleanup() {
+    if (handler_) {
+      (*handler_)(arg_);
+    }
+  }
+  void Reset(int execute) {
+    if (0 != execute && NULL != handler_) {
+      (*handler_)(arg_);
+    }
+    handler_ = NULL;
+  }
+
+ private:
+  CleanupHandler handler_;
+  void* arg_;
+};
+}
+#endif
diff --git a/src/OpenThreads/pthreads/PThreadCondition.c++ b/src/OpenThreads/pthreads/PThreadCondition.c++
--- a/src/OpenThreads/pthreads/PThreadCondition.c++
+++ b/src/OpenThreads/pthreads/PThreadCondition.c++
@@ -26,6 +26,7 @@
 #include <stdio.h>
 
 #include <OpenThreads/Condition>
+#include "PThreadCleanup.h"
 #include "PThreadConditionPrivateData.h"
 #include "PThreadMutexPrivateData.h"
 
@@ -132,11 +133,11 @@ int Condition::wait(Mutex *mutex) {
 
     int status;
     
-    pthread_cleanup_push(condition_cleanup_handler, &mpd->mutex);
+    PThreadCleanup thread_cleanup(condition_cleanup_handler, &mpd->mutex);
 
     status = pthread_cond_wait( &pd->condition, &mpd->mutex );
 
-    pthread_cleanup_pop(0);
+    thread_cleanup.Reset(0);
 
     return status;
 
@@ -179,11 +180,11 @@ int Condition::wait(Mutex *mutex, unsigned long int ms) {
 
     int status;
 
-    pthread_cleanup_push(condition_cleanup_handler, &mpd->mutex);
+    PThreadCleanup thread_cleanup(condition_cleanup_handler, &mpd->mutex);
 
     status = pthread_cond_timedwait( &pd->condition, &mpd->mutex, &abstime );
 
-    pthread_cleanup_pop(0);
+    thread_cleanup.Reset(0);
 
     return status;
 
diff --git a/src/OpenThreads/pthreads/PThreadPrivateData.h b/src/OpenThreads/pthreads/PThreadPrivateData.h
--- a/src/OpenThreads/pthreads/PThreadPrivateData.h
+++ b/src/OpenThreads/pthreads/PThreadPrivateData.h
@@ -25,6 +25,8 @@
 
 namespace OpenThreads {
 
+class Mutex;
+
 class PThreadPrivateData {
 
     //-------------------------------------------------------------------------
@@ -65,6 +67,8 @@ private:
     volatile int uniqueId;
 
     volatile int cpunum;
+
+    Mutex* isCanceledMutex;
     
 
     static int nextId;
diff --git a/src/osg/GLExtensions.cpp b/src/osg/GLExtensions.cpp
--- a/src/osg/GLExtensions.cpp
+++ b/src/osg/GLExtensions.cpp
@@ -27,9 +27,32 @@
 #include <set>
 
 #if defined(WIN32)
-#include <windows.h>
+    #ifndef WIN32_LEAN_AND_MEAN
+        #define WIN32_LEAN_AND_MEAN
+    #endif // WIN32_LEAN_AND_MEAN
+    #ifndef NOMINMAX
+        #define NOMINMAX
+    #endif // NOMINMAX
+    #include <windows.h>
+#elif !defined(OSG_GL_LIBRARY_STATIC)
+#if defined(__APPLE__)
+    // The NS*Symbol* stuff found in <mach-o/dyld.h> is deprecated.
+    // Since 10.3 (Panther) OS X has provided the dlopen/dlsym/dlclose
+    // family of functions under <dlfcn.h>. Since 10.4 (Tiger), Apple claimed
+    // the dlfcn family was significantly faster than the NS*Symbol* family.
+    // Since 'deprecated' needs to be taken very seriously with the
+    // coming of 10.5 (Leopard), it makes sense to use the dlfcn family when possible.
+    #include <AvailabilityMacros.h>
+    #if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)
+        #define USE_APPLE_LEGACY_NSSYMBOL
+        #include <mach-o/dyld.h>
+    #else
+        #include <dlfcn.h>
+    #endif
+#else
+    #include <dlfcn.h>
+#endif
 #endif
-
 
 typedef std::set<std::string>  ExtensionSet;
 static osg::buffered_object<ExtensionSet> s_glExtensionSetList;
@@ -91,18 +114,55 @@ bool osg::isGLExtensionOrVersionSupported(unsigned int contextID, const char *ex
             rendererString = renderer ? (const char*)renderer : "";
 
             // get the extension list from OpenGL.
-            const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
-            if (extensions==NULL) return false;
+            #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)
+            if( osg::getGLVersionNumber() >= 3.0 )
+            {
+                // OpenGL 3.0 adds the concept of indexed strings and
+                // deprecates calls to glGetString( GL_EXTENSIONS ), which
+                // will now generate GL_INVALID_ENUM.
 
-            // insert the ' ' delimiated extensions words into the extensionSet.
-            const char *startOfWord = extensions;
-            const char *endOfWord;
-            while ((endOfWord = strchr(startOfWord,' '))!=NULL)
+                // Get extensions using new indexed string interface.
+
+                typedef const GLubyte * GL_APIENTRY PFNGLGETSTRINGIPROC( GLenum, GLuint );
+                PFNGLGETSTRINGIPROC* glGetStringi = 0;
+                setGLExtensionFuncPtr( glGetStringi, "glGetStringi");
+
+                if( glGetStringi != NULL )
+                {
+                    #  ifndef GL_NUM_EXTENSIONS
+                    #    define GL_NUM_EXTENSIONS 0x821D
+                    #  endif
+                    GLint numExt;
+                    glGetIntegerv( GL_NUM_EXTENSIONS, &numExt );
+                    int idx;
+                    for( idx=0; idx<numExt; idx++ )
+                    {
+                        extensionSet.insert( std::string( (char*)( glGetStringi( GL_EXTENSIONS, idx ) ) ) );
+                    }
+                }
+                else
+                {
+                    osg::notify( osg::WARN ) << "isGLExtensionOrVersionSupported: Can't obtain glGetStringi function pointer." << std::endl;
+                }
+            }
+            else
+            #endif
             {
-                extensionSet.insert(std::string(startOfWord,endOfWord));
-                startOfWord = endOfWord+1;
+                // Get extensions using GL1/2 interface.
+
+                const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
+                if (extensions==NULL) return false;
+
+                // insert the ' ' delimiated extensions words into the extensionSet.
+                const char *startOfWord = extensions;
+                const char *endOfWord;
+                while ((endOfWord = strchr(startOfWord,' '))!=NULL)
+                {
+                    extensionSet.insert(std::string(startOfWord,endOfWord));
+                    startOfWord = endOfWord+1;
+                }
+                if (*startOfWord!=0) extensionSet.insert(std::string(startOfWord));
             }
-            if (*startOfWord!=0) extensionSet.insert(std::string(startOfWord));
 
     #if defined(WIN32) && (defined(OSG_GL1_AVAILABLE) || defined(OSG_GL2_AVAILABLE) || defined(OSG_GL3_AVAILABLE))
 
@@ -305,111 +365,97 @@
     }
 #endif
 
+#ifdef OSG_GL_LIBRARY_STATIC
 
+    #include "GLStaticLibrary.h"
+
+    void* osg::getGLExtensionFuncPtr(const char *funcName)
+    {
+        return GLStaticLibrary::getProcAddress(funcName);
+    }
 
-#if defined(WIN32)
-    #define WIN32_LEAN_AND_MEAN
-    #ifndef NOMINMAX
-        #define NOMINMAX
-    #endif // NOMINMAX
-    #include <windows.h>
-#elif defined(__APPLE__)
-    // The NS*Symbol* stuff found in <mach-o/dyld.h> is deprecated.
-    // Since 10.3 (Panther) OS X has provided the dlopen/dlsym/dlclose
-    // family of functions under <dlfcn.h>. Since 10.4 (Tiger), Apple claimed
-    // the dlfcn family was significantly faster than the NS*Symbol* family.
-    // Since 'deprecated' needs to be taken very seriously with the 
-    // coming of 10.5 (Leopard), it makes sense to use the dlfcn family when possible.
-    #include <AvailabilityMacros.h>
-    #if !defined(MAC_OS_X_VERSION_10_3) || (MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_3)
-        #define USE_APPLE_LEGACY_NSSYMBOL
-        #include <mach-o/dyld.h>
-    #else
-        #include <dlfcn.h>
-    #endif
 #else
-    #include <dlfcn.h>
-#endif
 
-void* osg::getGLExtensionFuncPtr(const char *funcName)
-{
-    // OSG_NOTIFY(osg::NOTICE)<<"osg::getGLExtensionFuncPtr("<<funcName<<")"<<std::endl;
-    
-#if defined(WIN32)
+    void* osg::getGLExtensionFuncPtr(const char *funcName)
+    {
+        // OSG_NOTIFY(osg::NOTICE)<<"osg::getGLExtensionFuncPtr("<<funcName<<")"<<std::endl;
 
-    #if defined(OSG_GLES2_AVAILABLE)
-        static HMODULE hmodule = GetModuleHandle("libGLESv2.dll");
-        return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));
-    #elif defined(OSG_GLES1_AVAILABLE)
-        static HMODULE hmodule = GetModuleHandle("libgles_cm.dll");
-        return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));
-    #else
-        return convertPointerType<void*, PROC>(wglGetProcAddress(funcName));
-    #endif
+    #if defined(WIN32)
 
-#elif defined(__APPLE__)
+        #if defined(OSG_GLES2_AVAILABLE)
+            static HMODULE hmodule = GetModuleHandle(TEXT("libGLESv2.dll"));
+            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));
+        #elif defined(OSG_GLES1_AVAILABLE)
+            static HMODULE hmodule = GetModuleHandleA(TEXT("libgles_cm.dll"));
+            return convertPointerType<void*, PROC>(GetProcAddress(hmodule, funcName));
+        #else
+            return convertPointerType<void*, PROC>(wglGetProcAddress(funcName));
+        #endif
+
+    #elif defined(__APPLE__)
+
+        #if defined(USE_APPLE_LEGACY_NSSYMBOL)
+            std::string temp( "_" );
+            temp += funcName;    // Mac OS X prepends an underscore on function names
+            if ( NSIsSymbolNameDefined( temp.c_str() ) )
+            {
+                NSSymbol symbol = NSLookupAndBindSymbol( temp.c_str() );
+                return NSAddressOfSymbol( symbol );
+            } else
+                return NULL;
+        #else
+            // I am uncertain of the correct and ideal usage of dlsym here.
+            // On the surface, it would seem that the FreeBSD implementation
+            // would be the ideal one to copy, but ELF and Mach-o are different
+            // and Apple's man page says the following about using RTLD_DEFAULT:
+            // "This can be a costly search and should be avoided."
+            // The documentation mentions nothing about passing in 0 so I must
+            // assume the behavior is undefined.
+            // So I could try copying the Sun method which I think all this
+            // actually originated from.
+
+            // return dlsym( RTLD_DEFAULT, funcName );
+            static void *handle = dlopen((const char *)0L, RTLD_LAZY);
+            return dlsym(handle, funcName);
+        #endif
 
-    #if defined(USE_APPLE_LEGACY_NSSYMBOL)
-        std::string temp( "_" );
-        temp += funcName;    // Mac OS X prepends an underscore on function names
-        if ( NSIsSymbolNameDefined( temp.c_str() ) )
-        {
-            NSSymbol symbol = NSLookupAndBindSymbol( temp.c_str() );
-            return NSAddressOfSymbol( symbol );
-        } else
-            return NULL;
-    #else
-        // I am uncertain of the correct and ideal usage of dlsym here.
-        // On the surface, it would seem that the FreeBSD implementation 
-        // would be the ideal one to copy, but ELF and Mach-o are different
-        // and Apple's man page says the following about using RTLD_DEFAULT: 
-        // "This can be a costly search and should be avoided."
-        // The documentation mentions nothing about passing in 0 so I must
-        // assume the behavior is undefined.
-        // So I could try copying the Sun method which I think all this 
-        // actually originated from.
+    #elif defined (__sun)
 
-        // return dlsym( RTLD_DEFAULT, funcName );
         static void *handle = dlopen((const char *)0L, RTLD_LAZY);
         return dlsym(handle, funcName);
-    #endif
 
-#elif defined (__sun) 
+    #elif defined (__sgi)
 
-     static void *handle = dlopen((const char *)0L, RTLD_LAZY);
-     return dlsym(handle, funcName);
-    
-#elif defined (__sgi)
+        static void *handle = dlopen((const char *)0L, RTLD_LAZY);
+        return dlsym(handle, funcName);
 
-     static void *handle = dlopen((const char *)0L, RTLD_LAZY);
-     return dlsym(handle, funcName);
+    #elif defined (__FreeBSD__)
 
-#elif defined (__FreeBSD__)
+        return dlsym( RTLD_DEFAULT, funcName );
 
-    return dlsym( RTLD_DEFAULT, funcName );
+    #elif defined (__linux__)
 
-#elif defined (__linux__)
+        typedef void (*__GLXextFuncPtr)(void);
+        typedef __GLXextFuncPtr (*GetProcAddressARBProc)(const char*);
 
-    typedef void (*__GLXextFuncPtr)(void);
-    typedef __GLXextFuncPtr (*GetProcAddressARBProc)(const char*);
-    
-    #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)
-    static GetProcAddressARBProc s_glXGetProcAddressARB = convertPointerType<GetProcAddressARBProc, void*>(dlsym(0, "glXGetProcAddressARB"));
-    if (s_glXGetProcAddressARB)
-    {
-        return convertPointerType<void*, __GLXextFuncPtr>((s_glXGetProcAddressARB)(funcName));
-    }
-    #endif
+        #if !defined(OSG_GLES1_AVAILABLE) && !defined(OSG_GLES2_AVAILABLE)
+        static GetProcAddressARBProc s_glXGetProcAddressARB = convertPointerType<GetProcAddressARBProc, void*>(dlsym(0, "glXGetProcAddressARB"));
+        if (s_glXGetProcAddressARB)
+        {
+            return convertPointerType<void*, __GLXextFuncPtr>((s_glXGetProcAddressARB)(funcName));
+        }
+        #endif
 
-    return dlsym(0, funcName);
+        return dlsym(0, funcName);
 
-#elif defined (__QNX__)
+    #elif defined (__QNX__)
 
-    return dlsym(RTLD_DEFAULT, funcName);
+        return dlsym(RTLD_DEFAULT, funcName);
 
-#else // all other unixes
+    #else // all other unixes
 
-    return dlsym(0, funcName);
+        return dlsym(0, funcName);
 
+    #endif
+    }
 #endif
-}
diff --git a/src/osg/GLStaticLibrary.cpp b/src/osg/GLStaticLibrary.cpp
new file mode 100644
--- /dev/null
+++ b/src/osg/GLStaticLibrary.cpp
@@ -0,0 +1,211 @@
+/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
+ * Copyright (C) 2003-2005 3Dlabs Inc. Ltd.
+ * Copyright (C) 2004-2005 Nathan Cournia
+ * Copyright (C) 2008 Zebra Imaging
+ *
+ * This application is open source and may be redistributed and/or modified   
+ * freely and without restriction, both in commericial and non commericial
+ * applications, as long as this copyright notice is maintained.
+ * 
+ * This application is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *
+*/
+
+/* file:        src/osg/GLStaticLibrary.cpp
+ * author:      Alok Priyadarshi 2010-04-27
+*/
+
+#include "GLStaticLibrary.h"
+#include <osg/GL>
+#include <osg/Notify>
+
+#include <map>
+#include <string>
+
+// This file is intended for GL static linking only.
+#if defined(OSG_GL_LIBRARY_STATIC)
+
+using namespace osg;
+
+namespace {
+typedef void (*GLProc)(void);
+typedef std::map<std::string, GLProc> GLProcAddressMap;
+static bool sProcAddressInitialized = false;
+static GLProcAddressMap sProcAddressMap;
+
+#define ADD_FUNCTION(FunctionName) sProcAddressMap[#FunctionName] = reinterpret_cast<GLProc>(&FunctionName);
+
+void initGLES2ProcAddress()
+{
+    ADD_FUNCTION(glActiveTexture)
+    ADD_FUNCTION(glAttachShader)
+    ADD_FUNCTION(glBindAttribLocation)
+    ADD_FUNCTION(glBindBuffer)
+    ADD_FUNCTION(glBindFramebuffer)
+    ADD_FUNCTION(glBindRenderbuffer)
+    ADD_FUNCTION(glBindTexture)
+    ADD_FUNCTION(glBlendColor)
+    ADD_FUNCTION(glBlendEquation)
+    ADD_FUNCTION(glBlendEquationSeparate)
+    ADD_FUNCTION(glBlendFunc)
+    ADD_FUNCTION(glBlendFuncSeparate)
+    ADD_FUNCTION(glBufferData)
+    ADD_FUNCTION(glBufferSubData)
+    ADD_FUNCTION(glCheckFramebufferStatus)
+    ADD_FUNCTION(glClear)
+    ADD_FUNCTION(glClearColor)
+    ADD_FUNCTION(glClearDepthf)
+    ADD_FUNCTION(glClearStencil)
+    ADD_FUNCTION(glColorMask)
+    ADD_FUNCTION(glCompileShader)
+    ADD_FUNCTION(glCompressedTexImage2D)
+    ADD_FUNCTION(glCompressedTexSubImage2D)
+    ADD_FUNCTION(glCopyTexImage2D)
+    ADD_FUNCTION(glCopyTexSubImage2D)
+    ADD_FUNCTION(glCreateProgram)
+    ADD_FUNCTION(glCreateShader)
+    ADD_FUNCTION(glCullFace)
+    ADD_FUNCTION(glDeleteBuffers)
+    ADD_FUNCTION(glDeleteFramebuffers)
+    ADD_FUNCTION(glDeleteProgram)
+    ADD_FUNCTION(glDeleteRenderbuffers)
+    ADD_FUNCTION(glDeleteShader)
+    ADD_FUNCTION(glDeleteTextures)
+    ADD_FUNCTION(glDepthFunc)
+    ADD_FUNCTION(glDepthMask)
+
+    ADD_FUNCTION(glDepthRangef)
+    ADD_FUNCTION(glDetachShader)
+    ADD_FUNCTION(glDisable)
+    ADD_FUNCTION(glDisableVertexAttribArray)
+    ADD_FUNCTION(glDrawArrays)
+    ADD_FUNCTION(glDrawElements)
+    ADD_FUNCTION(glEnable)
+    ADD_FUNCTION(glEnableVertexAttribArray)
+    ADD_FUNCTION(glFinish)
+    ADD_FUNCTION(glFlush)
+    ADD_FUNCTION(glFramebufferRenderbuffer)
+    ADD_FUNCTION(glFramebufferTexture2D)
+    ADD_FUNCTION(glFrontFace)
+    ADD_FUNCTION(glGenBuffers)
+    ADD_FUNCTION(glGenerateMipmap)
+    ADD_FUNCTION(glGenFramebuffers)
+    ADD_FUNCTION(glGenRenderbuffers)
+    ADD_FUNCTION(glGenTextures)
+    ADD_FUNCTION(glGetActiveAttrib)
+    ADD_FUNCTION(glGetActiveUniform)
+    ADD_FUNCTION(glGetAttachedShaders)
+    ADD_FUNCTION(glGetAttribLocation)
+    ADD_FUNCTION(glGetBooleanv)
+    ADD_FUNCTION(glGetBufferParameteriv)
+    ADD_FUNCTION(glGetError)
+    ADD_FUNCTION(glGetFloatv)
+    ADD_FUNCTION(glGetFramebufferAttachmentParameteriv)
+    ADD_FUNCTION(glGetIntegerv)
+    ADD_FUNCTION(glGetProgramiv)
+    ADD_FUNCTION(glGetProgramInfoLog)
+    ADD_FUNCTION(glGetRenderbufferParameteriv)
+    ADD_FUNCTION(glGetShaderiv)
+    ADD_FUNCTION(glGetShaderInfoLog)
+    ADD_FUNCTION(glGetShaderPrecisionFormat)
+    ADD_FUNCTION(glGetShaderSource)
+    ADD_FUNCTION(glGetString)
+    ADD_FUNCTION(glGetTexParameterfv)
+    ADD_FUNCTION(glGetTexParameteriv)
+    ADD_FUNCTION(glGetUniformfv)
+    ADD_FUNCTION(glGetUniformiv)
+    ADD_FUNCTION(glGetUniformLocation)
+    ADD_FUNCTION(glGetVertexAttribfv)
+    ADD_FUNCTION(glGetVertexAttribiv)
+    ADD_FUNCTION(glGetVertexAttribPointerv)
+    ADD_FUNCTION(glHint)
+    ADD_FUNCTION(glIsBuffer)
+    ADD_FUNCTION(glIsEnabled)
+    ADD_FUNCTION(glIsFramebuffer)
+    ADD_FUNCTION(glIsProgram)
+    ADD_FUNCTION(glIsRenderbuffer)
+    ADD_FUNCTION(glIsShader)
+    ADD_FUNCTION(glIsTexture)
+    ADD_FUNCTION(glLineWidth)
+    ADD_FUNCTION(glLinkProgram)
+    ADD_FUNCTION(glPixelStorei)
+    ADD_FUNCTION(glPolygonOffset)
+    ADD_FUNCTION(glReadPixels)
+    ADD_FUNCTION(glReleaseShaderCompiler)
+    ADD_FUNCTION(glRenderbufferStorage)
+    ADD_FUNCTION(glSampleCoverage)
+    ADD_FUNCTION(glScissor)
+    ADD_FUNCTION(glShaderBinary)
+    ADD_FUNCTION(glShaderSource)
+    ADD_FUNCTION(glStencilFunc)
+    ADD_FUNCTION(glStencilFuncSeparate)
+    ADD_FUNCTION(glStencilMask)
+    ADD_FUNCTION(glStencilMaskSeparate)
+    ADD_FUNCTION(glStencilOp)
+    ADD_FUNCTION(glStencilOpSeparate)
+    ADD_FUNCTION(glTexImage2D)
+    ADD_FUNCTION(glTexParameterf)
+    ADD_FUNCTION(glTexParameterfv)
+    ADD_FUNCTION(glTexParameteri)
+    ADD_FUNCTION(glTexParameteriv)
+    ADD_FUNCTION(glTexSubImage2D)
+    ADD_FUNCTION(glUniform1f)
+    ADD_FUNCTION(glUniform1fv)
+    ADD_FUNCTION(glUniform1i)
+    ADD_FUNCTION(glUniform1iv)
+    ADD_FUNCTION(glUniform2f)
+    ADD_FUNCTION(glUniform2fv)
+    ADD_FUNCTION(glUniform2i)
+    ADD_FUNCTION(glUniform2iv)
+    ADD_FUNCTION(glUniform3f)
+    ADD_FUNCTION(glUniform3fv)
+    ADD_FUNCTION(glUniform3i)
+    ADD_FUNCTION(glUniform3iv)
+    ADD_FUNCTION(glUniform4f)
+    ADD_FUNCTION(glUniform4fv)
+    ADD_FUNCTION(glUniform4i)
+    ADD_FUNCTION(glUniform4iv)
+    ADD_FUNCTION(glUniformMatrix2fv)
+    ADD_FUNCTION(glUniformMatrix3fv)
+    ADD_FUNCTION(glUniformMatrix4fv)
+    ADD_FUNCTION(glUseProgram)
+    ADD_FUNCTION(glValidateProgram)
+    ADD_FUNCTION(glVertexAttrib1f)
+    ADD_FUNCTION(glVertexAttrib1fv)
+    ADD_FUNCTION(glVertexAttrib2f)
+    ADD_FUNCTION(glVertexAttrib2fv)
+    ADD_FUNCTION(glVertexAttrib3f)
+    ADD_FUNCTION(glVertexAttrib3fv)
+    ADD_FUNCTION(glVertexAttrib4f)
+    ADD_FUNCTION(glVertexAttrib4fv)
+    ADD_FUNCTION(glVertexAttribPointer)
+    ADD_FUNCTION(glViewport)
+}
+
+void initProcAddress()
+{
+#if defined(OSG_GLES2_AVAILABLE)
+    initGLES2ProcAddress();
+#else
+    OSG_NOTICE << "initProcAddress() not implemented for static GL lib yet." << std::endl;
+#endif
+}
+
+}  // namespace
+
+void* GLStaticLibrary::getProcAddress(const char* procName)
+{
+    // TODO(alokp): Add a mutex around sProcAddressInitialized.
+    if (!sProcAddressInitialized)
+    {
+        initProcAddress();
+        sProcAddressInitialized = true;
+    }
+
+    GLProcAddressMap::const_iterator iter = sProcAddressMap.find(procName);
+    return reinterpret_cast<void*>(iter != sProcAddressMap.end() ? iter->second : 0);
+}
+
+#endif  // OSG_GLES2_LIBRARY_STATIC
diff --git a/src/osg/GLStaticLibrary.h b/src/osg/GLStaticLibrary.h
new file mode 100644
--- /dev/null
+++ b/src/osg/GLStaticLibrary.h
@@ -0,0 +1,33 @@
+/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield 
+ * Copyright (C) 2003-2005 3Dlabs Inc. Ltd.
+ * Copyright (C) 2004-2005 Nathan Cournia
+ * Copyright (C) 2007 Art Tevs
+ * Copyright (C) 2008 Zebra Imaging
+ *
+ * This application is open source and may be redistributed and/or modified   
+ * freely and without restriction, both in commericial and non commericial
+ * applications, as long as this copyright notice is maintained.
+ * 
+ * This application is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+*/
+
+/* file:        src/osg/GLStaticLibrary.h
+ * author:      Alok Priyadarshi 2010-04-27
+*/
+
+#ifndef OSG_GLSTATICLIBRARY
+#define OSG_GLSTATICLIBRARY 1
+
+namespace osg {
+
+class GLStaticLibrary
+{
+public:
+    static void* getProcAddress(const char* procName);
+};
+
+}
+
+#endif
diff --git a/src/osg/Makefile b/src/osg/Makefile
new file mode 100644
--- /dev/null
+++ b/src/osg/Makefile
@@ -0,0 +1,161 @@
+OSG_ROOT = ../..
+
+NACL_PORTS_PREFIX = ../../../../../toolchain/$(OS_PREFIX)_x86/nacl/usr
+
+NACLPORTS_INCLUDE = $(NACL_PORTS_PREFIX)/include
+
+NACLPORTS_LIBDIR = $(NACL_PORTS_PREFIX)/lib
+
+INCLUDE = -I$(OSG_ROOT)/include
+
+OBJ_FILES = \
+   AlphaFunc.o \
+   AnimationPath.o \
+   ApplicationUsage.o \
+   ArgumentParser.o \
+   Array.o \
+   ArrayDispatchers.o \
+   AudioStream.o \
+   AutoTransform.o \
+   Billboard.o \
+   BlendColor.o \
+   BlendEquation.o \
+   BlendFunc.o \
+   BufferObject.o \
+   Camera.o \
+   CameraView.o \
+   ClampColor.o \
+   ClearNode.o \
+   ClipNode.o \
+   ClipPlane.o \
+   ClusterCullingCallback.o \
+   CollectOccludersVisitor.o \
+   ColorMask.o \
+   ColorMatrix.o \
+   ComputeBoundsVisitor.o \
+   ConvexPlanarOccluder.o \
+   ConvexPlanarPolygon.o \
+   CoordinateSystemNode.o \
+   CopyOp.o \
+   CullFace.o \
+   CullSettings.o \
+   CullStack.o \
+   CullingSet.o \
+   DeleteHandler.o \
+   Depth.o \
+   DisplaySettings.o \
+   DrawPixels.o \
+   Drawable.o \
+   Fog.o \
+   FragmentProgram.o \
+   FrameBufferObject.o \
+   FrameStamp.o \
+   FrontFace.o \
+   GL2Extensions.o \
+   GLBeginEndAdapter.o \
+   GLExtensions.o \
+   GLObjects.o \
+   GLStaticLibrary.o \
+   Geode.o \
+   Geometry.o \
+   GraphicsContext.o \
+   GraphicsThread.o \
+   Group.o \
+   Hint.o \
+   Image.o \
+   ImageSequence.o \
+   ImageStream.o \
+   ImageUtils.o \
+   KdTree.o \
+   LOD.o \
+   Light.o \
+   LightModel.o \
+   LightSource.o \
+   LineSegment.o \
+   LineStipple.o \
+   LineWidth.o \
+   LogicOp.o \
+   Material.o \
+   Math.o \
+   MatrixDecomposition.o \
+   MatrixTransform.o \
+   Matrixd.o \
+   Matrixf.o \
+   Multisample.o \
+   Node.o \
+   NodeCallback.o \
+   NodeTrackerCallback.o \
+   NodeVisitor.o \
+   Notify.o \
+   Object.o \
+   Observer.o \
+   ObserverNodePath.o \
+   OccluderNode.o \
+   OcclusionQueryNode.o \
+   OperationThread.o \
+   PagedLOD.o \
+   Point.o \
+   PointSprite.o \
+   PolygonMode.o \
+   PolygonOffset.o \
+   PolygonStipple.o \
+   PositionAttitudeTransform.o \
+   PrimitiveSet.o \
+   Program.o \
+   Projection.o \
+   ProxyNode.o \
+   Quat.o \
+   Referenced.o \
+   Scissor.o \
+   Sequence.o \
+   ShadeModel.o \
+   Shader.o \
+   ShadowVolumeOccluder.o \
+   Shape.o \
+   ShapeDrawable.o \
+   State.o \
+   StateAttribute.o \
+   StateSet.o \
+   Stats.o \
+   Stencil.o \
+   StencilTwoSided.o \
+   Switch.o \
+   TexEnv.o \
+   TexEnvCombine.o \
+   TexEnvFilter.o \
+   TexGen.o \
+   TexGenNode.o \
+   TexMat.o \
+   Texture.o \
+   Texture1D.o \
+   Texture2D.o \
+   Texture2DArray.o \
+   Texture3D.o \
+   TextureCubeMap.o \
+   TextureRectangle.o \
+   Timer.o \
+   TransferFunction.o \
+   Transform.o \
+   Uniform.o \
+   Version.o \
+   VertexProgram.o \
+   View.o \
+   Viewport.o \
+   dxtctool.o
+
+OBJ_DIR = obj
+
+all: $(LIB_OSG)
+	@echo "Making libosg"
+
+clean:
+	rm -rf $(OBJ_DIR) $(LIB_OSG)
+
+$(OBJ_DIR):
+	mkdir $(OBJ_DIR)
+
+$(OBJ_FILES): %.o: %.cpp $(OBJ_DIR)
+	$(CXX) -c $(INCLUDE) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@
+
+$(LIB_OSG): $(OBJ_DIR) $(OBJ_FILES)
+	cd $(OBJ_DIR) && $(AR) rcs ../$(OSG_ROOT)/$(LIB_OSG) $(OBJ_FILES)
diff --git a/src/osg/Notify.cpp b/src/osg/Notify.cpp
--- a/src/osg/Notify.cpp
+++ b/src/osg/Notify.cpp
@@ -219,7 +219,7 @@ std::ostream& osg::notify(const osg::NotifySeverity severity)
 
 void osg::StandardNotifyHandler::notify(osg::NotifySeverity severity, const char *message)
 {
-#if 0
+#if 1
     if (severity <= osg::WARN) 
         fputs(message, stderr);
     else
@@ -231,7 +231,9 @@ void osg::StandardNotifyHandler::notify(osg::NotifySeverity severity, const char
 
 #if defined(WIN32) && !defined(__CYGWIN__)
 
-#define WIN32_LEAN_AND_MEAN
+#ifndef WIN32_LEAN_AND_MEAN
+    #define WIN32_LEAN_AND_MEAN
+#endif
 #include <windows.h>
 
 void osg::WinDebugNotifyHandler::notify(osg::NotifySeverity severity, const char *message)
diff --git a/src/osgUtil/Makefile b/src/osgUtil/Makefile
new file mode 100644
--- /dev/null
+++ b/src/osgUtil/Makefile
@@ -0,0 +1,66 @@
+OSG_ROOT = ../..
+
+NACL_PORTS_PREFIX = ../../../../../toolchain/$(OS_PREFIX)_x86/nacl/usr
+
+NACLPORTS_INCLUDE = $(NACL_PORTS_PREFIX)/include
+
+NACLPORTS_LIBDIR = $(NACL_PORTS_PREFIX)/lib
+
+INCLUDE = -I$(OSG_ROOT)/include
+
+INCLUDE = -I$(OSG_ROOT)/include
+
+OBJ_FILES = \
+   CubeMapGenerator.o \
+   CullVisitor.o \
+   DelaunayTriangulator.o \
+   DisplayRequirementsVisitor.o \
+   DrawElementTypeSimplifier.o \
+   EdgeCollector.o \
+   GLObjectsVisitor.o \
+   HalfWayMapGenerator.o \
+   HighlightMapGenerator.o \
+   IncrementalCompileOperation.o \
+   IntersectVisitor.o \
+   IntersectionVisitor.o \
+   LineSegmentIntersector.o \
+   Optimizer.o \
+   PlaneIntersector.o \
+   PolytopeIntersector.o \
+   PositionalStateContainer.o \
+   PrintVisitor.o \
+   RenderBin.o \
+   RenderLeaf.o \
+   RenderStage.o \
+   ReversePrimitiveFunctor.o \
+   SceneGraphBuilder.o \
+   SceneView.o \
+   ShaderGen.o \
+   Simplifier.o \
+   SmoothingVisitor.o \
+   StateGraph.o \
+   Statistics.o \
+   TangentSpaceGenerator.o \
+   Tessellator.o \
+   TransformAttributeFunctor.o \
+   TransformCallback.o \
+   TriStripVisitor.o \
+   UpdateVisitor.o \
+   Version.o
+
+OBJ_DIR = obj
+
+all: $(LIB_OSGUTIL)
+	@echo "Making libosgUtils"
+
+clean:
+	rm -rf $(OBJ_DIR) $(LIB_OSGUTIL)
+
+$(OBJ_DIR):
+	mkdir $(OBJ_DIR)
+
+$(OBJ_FILES): %.o: %.cpp $(OBJ_DIR)
+	$(CXX) -c $(INCLUDE) $(CXXFLAGS) $< -o $(OBJ_DIR)/$@
+
+$(LIB_OSGUTIL): $(OBJ_DIR) $(OBJ_FILES)
+	cd $(OBJ_DIR) && $(AR) rcs ../$(OSG_ROOT)/$(LIB_OSGUTIL) $(OBJ_FILES)
