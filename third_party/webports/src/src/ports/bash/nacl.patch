diff --git a/Makefile.in b/Makefile.in
--- a/Makefile.in
+++ b/Makefile.in
@@ -423,7 +423,8 @@ LIBRARY_LDFLAGS = $(READLINE_LDFLAGS) $(HISTORY_LDFLAGS) $(GLOB_LDFLAGS) \
 #
 
 # The main source code for the Bourne Again SHell.
-CSOURCES = shell.c eval.c parse.y general.c make_cmd.c print_cmd.c y.tab.c \
+CSOURCES = \
+	   shell.c eval.c parse.y general.c make_cmd.c print_cmd.c y.tab.c \
 	   dispose_cmd.c execute_cmd.c variables.c $(GLOBC) version.c \
 	   expr.c copy_cmd.c flags.c subst.c hashcmd.c hashlib.c mailcheck.c \
 	   test.c trap.c alias.c jobs.c nojobs.c $(ALLOC_FILES) braces.c \
@@ -452,7 +453,8 @@ SIGLIST_O = @SIGLIST_O@
 SIGNAMES_O = @SIGNAMES_O@
 
 # Matching object files.
-OBJECTS	 = shell.o eval.o y.tab.o general.o make_cmd.o print_cmd.o $(GLOBO) \
+OBJECTS	 = \
+	   shell.o eval.o y.tab.o general.o make_cmd.o print_cmd.o $(GLOBO) \
 	   dispose_cmd.o execute_cmd.o variables.o copy_cmd.o error.o \
 	   expr.o flags.o $(JOBS_O) subst.o hashcmd.o hashlib.o mailcheck.o \
 	   trap.o input.o unwind_prot.o pathexp.o sig.o test.o version.o \
@@ -551,7 +553,7 @@ OTHER_INSTALLED_DOCS = CHANGES COMPAT NEWS POSIX RBASH README
 
 $(Program):  .build $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
 	$(RM) $@
-	$(PURIFY) $(CC) $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
+	$(PURIFY) $(CC) $(BUILTINS_LDFLAGS) $(LIBRARY_LDFLAGS) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS) $(EXTRA_LIBS)
 	ls -l $(Program)
 	-$(SIZE) $(Program)
 
diff --git a/bashline.c b/bashline.c
--- a/bashline.c
+++ b/bashline.c
@@ -2379,7 +2379,7 @@ bash_groupname_completion_function (text, state)
      const char *text;
      int state;
 {
-#if defined (__WIN32__) || defined (__OPENNT) || !defined (HAVE_GRP_H)
+#if defined (__WIN32__) || defined (__OPENNT) || !defined (HAVE_GRP_H) || (defined(__native_client__) && defined(_NEWLIB_VERSION))
   return ((char *)NULL);
 #else
   static char *gname = (char *)NULL;
diff --git a/configure b/configure
--- a/configure
+++ b/configure
@@ -2867,6 +2867,7 @@ sparc-linux*)	opt_bash_malloc=no ;;	# sparc running linux; requires ELF
 *-bsdi2.1|*-bsdi3.?)	opt_bash_malloc=no ; : ${CC:=shlicc2} ;; # for loadable builtins
 *-beos*)	opt_bash_malloc=no ;;	# they say it's suitable
 *-cygwin*)	opt_bash_malloc=no ;;	# Cygnus's CYGWIN environment
+*nacl*) 	opt_bash_malloc=no ;;	# Native Client
 *-opennt*|*-interix*)	opt_bash_malloc=no ;;	# Interix, now owned by Microsoft
 *-nsk*)		opt_bash_malloc=no ;;	# HP NonStop
 *-haiku*)	opt_bash_malloc=no ;;	# Haiku OS
@@ -5278,7 +5279,7 @@ if ${ac_cv_rl_version+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   if test "$cross_compiling" = yes; then :
-  ac_cv_rl_version='4.2'
+  ac_cv_rl_version='6.2'
 else
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
diff --git a/eval.c b/eval.c
--- a/eval.c
+++ b/eval.c
@@ -271,7 +271,10 @@ read_command ()
 	  if (tmout_len > 0)
 	    {
 	      old_alrm = set_signal_handler (SIGALRM, alrm_catcher);
+#if !defined(__native_client__) || !defined(_NEWLIB_VERSION)
+              /* TODO(bradnelson): Drop once we emulate signals. */
 	      alarm (tmout_len);
+#endif
 	    }
 	}
     }
@@ -283,7 +286,10 @@ read_command ()
 
   if (interactive && tmout_var && (tmout_len > 0))
     {
+#if !defined(__native_client__) || !defined(_NEWLIB_VERSION)
+      /* TODO(bradnelson): Drop once we emulate signals. */
       alarm(0);
+#endif
       set_signal_handler (SIGALRM, old_alrm);
     }
 
diff --git a/execute_cmd.c b/execute_cmd.c
--- a/execute_cmd.c
+++ b/execute_cmd.c
@@ -98,6 +98,10 @@ extern int errno;
 #  include "bashhist.h"
 #endif
 
+#if defined(__native_client__)
+#  include <spawn.h>
+#endif
+
 extern int dollar_dollar_pid;
 extern int posixly_correct;
 extern int expand_aliases;
@@ -2369,7 +2373,11 @@ execute_pipeline (command, asynchronous, pipe_in, pipe_out, fds_to_close)
   /* If the `lastpipe' option is set with shopt, and job control is not
      enabled, execute the last element of non-async pipelines in the
      current shell environment. */
+#if defined(JOB_CONTROL)
   if (lastpipe_opt && job_control == 0 && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
+#else
+  if (lastpipe_opt && asynchronous == 0 && pipe_out == NO_PIPE && prev > 0)
+#endif
     {
       lstdin = move_to_high_fd (0, 1, -1);
       if (lstdin > 0)
@@ -4873,6 +4881,33 @@ execute_disk_command (words, redirects, command_line, pipe_in, pipe_out,
   SHELL_VAR *hookf;
   WORD_LIST *wl;
 
+#if defined(__native_client__)
+  // Update environ.
+  maybe_make_export_env ();
+  args = strvec_from_word_list (words, 0, 0, (int *)NULL);
+  pathname = words->word->word;
+  pid = spawnve(P_NOWAIT, args[0], args, NULL);
+  free(args);
+  if (pid < 0) {
+    /* Make sure filenames are displayed using printable characters */
+    if (ansic_shouldquote (pathname))
+      pathname = ansic_quote (pathname, 0, NULL);
+    if (errno == ENOENT) {
+      internal_error (_("%s: command not found"), pathname);
+    } else {
+      internal_error (_("%s: nacl_spawn failed (errno %d)"), pathname, errno);
+    }
+    return EX_NOTFOUND;  /* Posix.2 says the exit status is 127 */
+  }
+  if (waitpid(pid, &result, 0) < 0) {
+    if (ansic_shouldquote (pathname))
+      pathname = ansic_quote (pathname, 0, NULL);
+    internal_error (_("%s: waitpid failed (errno %d)"), pathname, errno);
+    return EXECUTION_FAILURE;
+  }
+  /* TODO(bradnelson): Make this more general once we support signals. */
+  return WEXITSTATUS(result);
+#else
   nofork = (cmdflags & CMD_NO_FORK);  /* Don't fork, just exec, if no pipes */
   pathname = words->word->word;
 
@@ -5005,6 +5040,7 @@ parent_return:
       FREE (command);
       return (result);
     }
+#endif
 }
 
 /* CPP defines to decide whether a particular index into the #! line
diff --git a/jobs.h b/jobs.h
--- a/jobs.h
+++ b/jobs.h
@@ -56,7 +56,11 @@
 typedef struct process {
   struct process *next;	/* Next process in the pipeline.  A circular chain. */
   pid_t pid;		/* Process ID. */
+#if defined(__native_client__) && defined(_NEWLIB_VERSION)
+  int status;		/* The status of this command as returned by wait. */
+#else
   WAIT status;		/* The status of this command as returned by wait. */
+#endif
   int running;		/* Non-zero if this process is running. */
   char *command;	/* The particular program that is running. */
 } PROCESS;
diff --git a/lib/sh/ufuncs.c b/lib/sh/ufuncs.c
--- a/lib/sh/ufuncs.c
+++ b/lib/sh/ufuncs.c
@@ -65,6 +65,10 @@ int
 falarm (secs, usecs)
      unsigned int secs, usecs;
 {
+#if defined(__native_client__) && defined(_NEWLIB_VERSION)
+  /* TODO(bradnelson): Remove this once we emulate signals. */
+  return 0;
+#else
   if (secs == 0 && usecs == 0)
     return (alarm (0));
 
@@ -74,6 +78,7 @@ falarm (secs, usecs)
       usecs = 0;
     }
   return (alarm (secs));
+#endif
 }
 #endif /* !HAVE_SETITIMER */
 
diff --git a/nojobs.c b/nojobs.c
--- a/nojobs.c
+++ b/nojobs.c
@@ -65,6 +65,10 @@
 #  define WAITPID(pid, statusp, options) wait (statusp)
 #endif /* !HAVE_WAITPID */
 
+#if defined(__native_client__) && defined(_NEWLIB_VERSION)
+#  define WAIT int
+#endif
+
 /* Return the fd from which we are actually getting input. */
 #define input_tty() (shell_tty != -1) ? shell_tty : fileno (stderr)
 
@@ -775,7 +779,7 @@ wait_for (pid)
       CHECK_WAIT_INTR;
       if (got_pid < 0 && errno == ECHILD)
 	{
-#if !defined (_POSIX_VERSION)
+#if !defined (_POSIX_VERSION) && (!defined(__native_client__) || !defined(_NEWLIB_VERSION))
 	  status.w_termsig = status.w_retcode = 0;
 #else
 	  status = 0;
@@ -839,8 +843,10 @@ wait_for (pid)
   if ((WIFSTOPPED (status) == 0) && WIFSIGNALED (status) && REPORTSIG(WTERMSIG (status)))
     {
       fprintf (stderr, "%s", j_strsignal (WTERMSIG (status)));
+#if !defined(__native_client__) || !defined(_NEWLIB_VERSION)
       if (WIFCORED (status))
 	fprintf (stderr, _(" (core dumped)"));
+#endif
       fprintf (stderr, "\n");
     }
 
diff --git a/shell.c b/shell.c
--- a/shell.c
+++ b/shell.c
@@ -365,7 +365,7 @@ main (argc, argv, env)
 #endif
   volatile int locally_skip_execution;
   volatile int arg_index, top_level_arg_index;
-#ifdef __OPENNT
+#if defined(__OPENNT) || defined(__native_client__)
   char **env;
 
   env = environ;
@@ -1717,10 +1717,14 @@ shell_initialize ()
   if (current_host_name == 0)
     {
       /* Initialize current_host_name. */
+#if defined(__native_client__)
+      current_host_name = "mingn";
+#else
       if (gethostname (hostname, 255) < 0)
 	current_host_name = "??host??";
       else
 	current_host_name = savestring (hostname);
+#endif
     }
 
   /* Initialize the stuff in current_user that comes from the password
