diff --git a/find/Makefile.in b/find/Makefile.in
--- a/find/Makefile.in
+++ b/find/Makefile.in
@@ -198,7 +198,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/build-aux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
-AR = ar
+AR ?= ar
 ARFLAGS = cru
 libfindtools_a_AR = $(AR) $(ARFLAGS)
 libfindtools_a_LIBADD =
@@ -691,13 +691,13 @@ installcheck-binPROGRAMS: $(bin_PROGRAMS)
 	done; rm -f c$${pid}_.???; exit $$bad
 find$(EXEEXT): $(find_OBJECTS) $(find_DEPENDENCIES) 
 	@rm -f find$(EXEEXT)
-	$(LINK) $(find_OBJECTS) $(find_LDADD) $(LIBS)
+	$(LINK) $(find_OBJECTS) $(find_LDADD) ${NACL_CLI_MAIN_LIB} $(LIBS)
 ftsfind$(EXEEXT): $(ftsfind_OBJECTS) $(ftsfind_DEPENDENCIES) 
 	@rm -f ftsfind$(EXEEXT)
 	$(LINK) $(ftsfind_OBJECTS) $(ftsfind_LDADD) $(LIBS)
 oldfind$(EXEEXT): $(oldfind_OBJECTS) $(oldfind_DEPENDENCIES) 
 	@rm -f oldfind$(EXEEXT)
-	$(LINK) $(oldfind_OBJECTS) $(oldfind_LDADD) $(LIBS)
+	$(LINK) $(oldfind_OBJECTS) $(oldfind_LDADD) ${NACL_CLI_MAIN_LIB} $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
diff --git a/find/ftsfind.c b/find/ftsfind.c
--- a/find/ftsfind.c
+++ b/find/ftsfind.c
@@ -74,7 +74,6 @@
 # define N_(String) String
 #endif
 
-
 static void set_close_on_exec(int fd)
 {
 #if defined F_GETFD && defined FD_CLOEXEC
diff --git a/find/pred.c b/find/pred.c
--- a/find/pred.c
+++ b/find/pred.c
@@ -24,6 +24,7 @@
 #include <math.h>
 #include <pwd.h>
 #include <grp.h>
+#include <spawn.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <errno.h>
@@ -1948,7 +1949,7 @@ launch (const struct buildcmd_control *ctl,
       signal (SIGCHLD, SIG_DFL);
     }
 
-  child_pid = fork ();
+  child_pid = vfork ();
   if (child_pid == -1)
     error (1, errno, _("cannot fork"));
   if (child_pid == 0)
diff --git a/gnulib/lib/Makefile.am b/gnulib/lib/Makefile.am
--- a/gnulib/lib/Makefile.am
+++ b/gnulib/lib/Makefile.am
@@ -858,7 +858,7 @@ EXTRA_libgnulib_a_SOURCES += memset.c
 ## begin gnulib module mktime
 
 
-EXTRA_DIST += mktime.c
+EXTRA_DIST += mktime-internal.h mktime.c
 
 EXTRA_libgnulib_a_SOURCES += mktime.c
 
diff --git a/gnulib/lib/Makefile.in b/gnulib/lib/Makefile.in
--- a/gnulib/lib/Makefile.in
+++ b/gnulib/lib/Makefile.in
@@ -209,7 +209,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/build-aux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
-AR = ar
+AR ?= ar
 ARFLAGS = cru
 libgnulib_a_AR = $(AR) $(ARFLAGS)
 am__DEPENDENCIES_1 =
@@ -609,7 +609,7 @@ EXTRA_DIST = alloca.c alloca.in.h areadlink.h argmatch.c argmatch.h \
 	$(top_srcdir)/build-aux/link-warning.h config.charset \
 	ref-add.sin ref-del.sin lseek.c lstat.c lstat.h malloc.c \
 	malloc.c malloca.h malloca.valgrind mbchar.h memchr.c memcmp.c \
-	mempcpy.c memrchr.c memset.c mktime.c modechange.c \
+	mempcpy.c memrchr.c memset.c mktime-internal.h mktime.c modechange.c \
 	modechange.h mountlist.c mountlist.h at-func.c fchmodat.c \
 	fchownat.c fstatat.c mkdirat.c openat-priv.h openat-proc.c \
 	openat.c openat.h pathmax.h quote.c quote.h quotearg.c \
diff --git a/gnulib/lib/fpending.c b/gnulib/lib/fpending.c
--- a/gnulib/lib/fpending.c
+++ b/gnulib/lib/fpending.c
@@ -22,8 +22,14 @@
 
 /* Return the number of pending (aka buffered, unflushed)
    bytes on the stream, FP, that is open for writing.  */
+
+/* we already have __fpending x86_64-nacl/include/stdio_ext.h 
+   Add thess two macro, otherwise we will get 
+   redefinition of ‘__fpending’ error */
+#if !defined(__native_client__)
 size_t
 __fpending (FILE *fp)
 {
   return PENDING_OUTPUT_N_BYTES;
 }
+#endif
\ No newline at end of file
diff --git a/gnulib/lib/getdate.y b/gnulib/lib/getdate.y
--- a/gnulib/lib/getdate.y
+++ b/gnulib/lib/getdate.y
@@ -114,7 +114,9 @@
    wraps around, but there's no portable way to check for that at
    compile-time.  */
 verify (TYPE_IS_INTEGER (time_t));
+#if !defined(__native_client__)
 verify (LONG_MIN <= TYPE_MINIMUM (time_t) && TYPE_MAXIMUM (time_t) <= LONG_MAX);
+#endif
 
 /* An integer value, and the number of digits in its textual
    representation.  */
diff --git a/gnulib/lib/mktime-internal.h b/gnulib/lib/mktime-internal.h
new file mode 100644
--- /dev/null
+++ b/gnulib/lib/mktime-internal.h
@@ -0,0 +1,4 @@
+#include <time.h>
+time_t mktime_internal (struct tm *,
+                        struct tm * (*) (time_t const *, struct tm *),
+                        time_t *);
\ No newline at end of file
diff --git a/gnulib/lib/mktime.c b/gnulib/lib/mktime.c
--- a/gnulib/lib/mktime.c
+++ b/gnulib/lib/mktime.c
@@ -1,21 +1,21 @@
-/* Convert a `struct tm' to a time_t value.
-   Copyright (C) 1993-1999, 2002-2005, 2006, 2007 Free Software Foundation, Inc.
+/* Convert a 'struct tm' to a time_t value.
+   Copyright (C) 1993-2015 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Paul Eggert <eggert@twinsun.com>.
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
 
-   This program is distributed in the hope that it will be useful,
+   The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
 
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation,
-   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA. */
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
 
 /* Define this to have a standalone program to test this implementation of
    mktime.  */
@@ -26,7 +26,7 @@
 #endif
 
 /* Assume that leap seconds are possible, unless told otherwise.
-   If the host has a `zic' command with a `-L leapsecondfilename' option,
+   If the host has a 'zic' command with a '-L leapsecondfilename' option,
    then it supports leap seconds; otherwise it probably doesn't.  */
 #ifndef LEAP_SECONDS_POSSIBLE
 # define LEAP_SECONDS_POSSIBLE 1
@@ -36,15 +36,49 @@
 
 #include <limits.h>
 
-#include <string.h>		/* For the real memcpy prototype.  */
+#include <string.h>   /* For the real memcpy prototype.  */
 
-#if DEBUG
+#if defined DEBUG && DEBUG
 # include <stdio.h>
 # include <stdlib.h>
 /* Make it work even if the system's libc has its own mktime routine.  */
+# undef mktime
 # define mktime my_mktime
 #endif /* DEBUG */
 
+/* Some of the code in this file assumes that signed integer overflow
+   silently wraps around.  This assumption can't easily be programmed
+   around, nor can it be checked for portably at compile-time or
+   easily eliminated at run-time.
+
+   Define WRAPV to 1 if the assumption is valid and if
+     #pragma GCC optimize ("wrapv")
+   does not trigger GCC bug 51793
+   <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51793>.
+   Otherwise, define it to 0; this forces the use of slower code that,
+   while not guaranteed by the C Standard, works on all production
+   platforms that we know about.  */
+#ifndef WRAPV
+# if (((__GNUC__ == 4 && 4 <= __GNUC_MINOR__) || 4 < __GNUC__) \
+      && defined __GLIBC__)
+#  pragma GCC optimize ("wrapv")
+#  define WRAPV 1
+# else
+#  define WRAPV 0
+# endif
+#endif
+
+/* Verify a requirement at compile-time (unlike assert, which is runtime).  */
+#define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
+
+/* A signed type that is at least one bit wider than int.  */
+#if INT_MAX <= LONG_MAX / 2
+typedef long int long_int;
+#else
+typedef long long int long_int;
+#endif
+verify (long_int_is_wide_enough, INT_MAX == INT_MAX * (long_int) 2 / 2);
+
 /* Shift A right by B bits portably, by dividing A by 2**B and
    truncating towards minus infinity.  A and B should be free of side
    effects, and B should be in the range 0 <= B <= INT_BITS - 2, where
@@ -55,9 +89,11 @@
    implementations (e.g., UNICOS 9.0 on a Cray Y-MP EL) don't shift
    right in the usual way when A < 0, so SHR falls back on division if
    ordinary A >> B doesn't seem to be the usual signed shift.  */
-#define SHR(a, b)	\
-  (-1 >> 1 == -1	\
-   ? (a) >> (b)		\
+#define SHR(a, b)                                               \
+  ((-1 >> 1 == -1                                               \
+    && (long_int) -1 >> 1 == -1                                 \
+    && ((time_t) -1 >> 1 == -1 || ! TYPE_SIGNED (time_t)))      \
+   ? (a) >> (b)                                                 \
    : (a) / (1 << (b)) - ((a) % (1 << (b)) < 0))
 
 /* The extra casts in the following macros work around compiler bugs,
@@ -68,12 +104,8 @@
 #define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
 
 /* True if negative values of the signed integer type T use two's
-   complement, ones' complement, or signed magnitude representation,
-   respectively.  Much GNU code assumes two's complement, but some
-   people like to be portable to all possible C hosts.  */
+   complement, or if T is an unsigned integer type.  */
 #define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
-#define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
-#define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
 
 /* True if the arithmetic type T is signed.  */
 #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
@@ -84,14 +116,12 @@
    your host.  */
 #define TYPE_MINIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) 0 \
-	: TYPE_SIGNED_MAGNITUDE (t) \
-	? ~ (t) 0 \
-	: ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+  ? (t) 0 \
+  : ~ TYPE_MAXIMUM (t)))
 #define TYPE_MAXIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) -1 \
-	: ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+  ? (t) -1 \
+  : ((((t) 1 << (sizeof (t) * CHAR_BIT - 2)) - 1) * 2 + 1)))
 
 #ifndef TIME_T_MIN
 # define TIME_T_MIN TYPE_MINIMUM (time_t)
@@ -101,29 +131,26 @@
 #endif
 #define TIME_T_MIDPOINT (SHR (TIME_T_MIN + TIME_T_MAX, 1) + 1)
 
-/* Verify a requirement at compile-time (unlike assert, which is runtime).  */
-#define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
-
 verify (time_t_is_integer, TYPE_IS_INTEGER (time_t));
-verify (twos_complement_arithmetic, TYPE_TWOS_COMPLEMENT (int));
-/* The code also assumes that signed integer overflow silently wraps
-   around, but this assumption can't be stated without causing a
-   diagnostic on some hosts.  */
+verify (twos_complement_arithmetic,
+  (TYPE_TWOS_COMPLEMENT (int)
+   && TYPE_TWOS_COMPLEMENT (long_int)
+   && TYPE_TWOS_COMPLEMENT (time_t)));
 
 #define EPOCH_YEAR 1970
 #define TM_YEAR_BASE 1900
 verify (base_year_is_a_multiple_of_100, TM_YEAR_BASE % 100 == 0);
 
 /* Return 1 if YEAR + TM_YEAR_BASE is a leap year.  */
-static inline int
-leapyear (long int year)
+static int
+leapyear (long_int year)
 {
   /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.
      Also, work even if YEAR is negative.  */
   return
     ((year & 3) == 0
      && (year % 100 != 0
-	 || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));
+   || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));
 }
 
 /* How many days come before each month (0-12).  */
@@ -147,8 +174,17 @@ const unsigned short int __mon_yday[2][13] =
 # undef __localtime_r
 # define __localtime_r localtime_r
 # define __mktime_internal mktime_internal
+# include "mktime-internal.h"
 #endif
 
+/* Return 1 if the values A and B differ according to the rules for
+   tm_isdst: A and B differ if one is zero and the other positive.  */
+static int
+isdst_differ (int a, int b)
+{
+  return (!a != !b) && (0 <= a) && (0 <= b);
+}
+
 /* Return an integer value measuring (YEAR1-YDAY1 HOUR1:MIN1:SEC1) -
    (YEAR0-YDAY0 HOUR0:MIN0:SEC0) in seconds, assuming that the clocks
    were not adjusted between the time stamps.
@@ -160,13 +196,11 @@ const unsigned short int __mon_yday[2][13] =
    The result may overflow.  It is the caller's responsibility to
    detect overflow.  */
 
-static inline time_t
-ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
-	    int year0, int yday0, int hour0, int min0, int sec0)
+static time_t
+ydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,
+      int year0, int yday0, int hour0, int min0, int sec0)
 {
   verify (C99_integer_division, -1 / 2 == 0);
-  verify (long_int_year_and_yday_are_wide_enough,
-	  INT_MAX <= LONG_MAX / 2 || TIME_T_MAX <= UINT_MAX);
 
   /* Compute intervening leap days correctly even if year is negative.
      Take care to avoid integer overflow here.  */
@@ -189,6 +223,53 @@ ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
   return seconds;
 }
 
+/* Return the average of A and B, even if A + B would overflow.  */
+static time_t
+time_t_avg (time_t a, time_t b)
+{
+  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);
+}
+
+/* Return 1 if A + B does not overflow.  If time_t is unsigned and if
+   B's top bit is set, assume that the sum represents A - -B, and
+   return 1 if the subtraction does not wrap around.  */
+static int
+time_t_add_ok (time_t a, time_t b)
+{
+  if (! TYPE_SIGNED (time_t))
+    {
+      time_t sum = a + b;
+      return (sum < a) == (TIME_T_MIDPOINT <= b);
+    }
+  else if (WRAPV)
+    {
+      time_t sum = a + b;
+      return (sum < a) == (b < 0);
+    }
+  else
+    {
+      time_t avg = time_t_avg (a, b);
+      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;
+    }
+}
+
+/* Return 1 if A + B does not overflow.  */
+static int
+time_t_int_add_ok (time_t a, int b)
+{
+  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);
+  if (WRAPV)
+    {
+      time_t sum = a + b;
+      return (sum < a) == (b < 0);
+    }
+  else
+    {
+      int a_odd = a & 1;
+      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));
+      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;
+    }
+}
 
 /* Return a time_t value corresponding to (YEAR-YDAY HOUR:MIN:SEC),
    assuming that *T corresponds to *TP and that no clock adjustments
@@ -197,17 +278,16 @@ ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
    If overflow occurs, yield the minimal or maximal value, except do not
    yield a value equal to *T.  */
 static time_t
-guess_time_tm (long int year, long int yday, int hour, int min, int sec,
-	       const time_t *t, const struct tm *tp)
+guess_time_tm (long_int year, long_int yday, int hour, int min, int sec,
+         const time_t *t, const struct tm *tp)
 {
   if (tp)
     {
       time_t d = ydhms_diff (year, yday, hour, min, sec,
-			     tp->tm_year, tp->tm_yday,
-			     tp->tm_hour, tp->tm_min, tp->tm_sec);
-      time_t t1 = *t + d;
-      if ((t1 < *t) == (TYPE_SIGNED (time_t) ? d < 0 : TIME_T_MAX / 2 < d))
-	return t1;
+           tp->tm_year, tp->tm_yday,
+           tp->tm_hour, tp->tm_min, tp->tm_sec);
+      if (time_t_add_ok (*t, d))
+  return *t + d;
     }
 
   /* Overflow occurred one way or another.  Return the nearest result
@@ -216,8 +296,8 @@ guess_time_tm (long int year, long int yday, int hour, int min, int sec,
      match; and don't oscillate between two values, as that would
      confuse the spring-forward gap detector.  */
   return (*t < TIME_T_MIDPOINT
-	  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)
-	  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));
+    ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)
+    : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));
 }
 
 /* Use CONVERT to convert *T to a broken down time in *TP.
@@ -225,7 +305,7 @@ guess_time_tm (long int year, long int yday, int hour, int min, int sec,
    it is the nearest in-range value and then convert that.  */
 static struct tm *
 ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
-		time_t *t, struct tm *tp)
+    time_t *t, struct tm *tp)
 {
   struct tm *r = convert (t, tp);
 
@@ -235,27 +315,25 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
       time_t ok = 0;
 
       /* BAD is a known unconvertible time_t, and OK is a known good one.
-	 Use binary search to narrow the range between BAD and OK until
-	 they differ by 1.  */
+   Use binary search to narrow the range between BAD and OK until
+   they differ by 1.  */
       while (bad != ok + (bad < 0 ? -1 : 1))
-	{
-	  time_t mid = *t = (bad < 0
-			     ? bad + ((ok - bad) >> 1)
-			     : ok + ((bad - ok) >> 1));
-	  r = convert (t, tp);
-	  if (r)
-	    ok = mid;
-	  else
-	    bad = mid;
-	}
+  {
+    time_t mid = *t = time_t_avg (ok, bad);
+    r = convert (t, tp);
+    if (r)
+      ok = mid;
+    else
+      bad = mid;
+  }
 
       if (!r && ok)
-	{
-	  /* The last conversion attempt failed;
-	     revert to the most recent successful attempt.  */
-	  *t = ok;
-	  r = convert (t, tp);
-	}
+  {
+    /* The last conversion attempt failed;
+       revert to the most recent successful attempt.  */
+    *t = ok;
+    r = convert (t, tp);
+  }
     }
 
   return r;
@@ -270,8 +348,8 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
    This function is external because it is used also by timegm.c.  */
 time_t
 __mktime_internal (struct tm *tp,
-		   struct tm *(*convert) (const time_t *, struct tm *),
-		   time_t *offset)
+       struct tm *(*convert) (const time_t *, struct tm *),
+       time_t *offset)
 {
   time_t t, gt, t0, t1, t2;
   struct tm tm;
@@ -299,8 +377,8 @@ __mktime_internal (struct tm *tp,
   int mon_remainder = mon % 12;
   int negative_mon_remainder = mon_remainder < 0;
   int mon_years = mon / 12 - negative_mon_remainder;
-  long int lyear_requested = year_requested;
-  long int year = lyear_requested + mon_years;
+  long_int lyear_requested = year_requested;
+  long_int year = lyear_requested + mon_years;
 
   /* The other values need not be in range:
      the remaining code handles minor overflows correctly,
@@ -310,10 +388,10 @@ __mktime_internal (struct tm *tp,
   /* Calculate day of year from year, month, and day of month.
      The result need not be in range.  */
   int mon_yday = ((__mon_yday[leapyear (year)]
-		   [mon_remainder + 12 * negative_mon_remainder])
-		  - 1);
-  long int lmday = mday;
-  long int yday = mon_yday + lmday;
+       [mon_remainder + 12 * negative_mon_remainder])
+      - 1);
+  long_int lmday = mday;
+  long_int yday = mon_yday + lmday;
 
   time_t guessed_offset = *offset;
 
@@ -322,33 +400,33 @@ __mktime_internal (struct tm *tp,
   if (LEAP_SECONDS_POSSIBLE)
     {
       /* Handle out-of-range seconds specially,
-	 since ydhms_tm_diff assumes every minute has 60 seconds.  */
+   since ydhms_tm_diff assumes every minute has 60 seconds.  */
       if (sec < 0)
-	sec = 0;
+  sec = 0;
       if (59 < sec)
-	sec = 59;
+  sec = 59;
     }
 
   /* Invert CONVERT by probing.  First assume the same offset as last
      time.  */
 
   t0 = ydhms_diff (year, yday, hour, min, sec,
-		   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);
+       EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);
 
   if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
     {
       /* time_t isn't large enough to rule out overflows, so check
-	 for major overflows.  A gross check suffices, since if t0
-	 has overflowed, it is off by a multiple of TIME_T_MAX -
-	 TIME_T_MIN + 1.  So ignore any component of the difference
-	 that is bounded by a small value.  */
+   for major overflows.  A gross check suffices, since if t0
+   has overflowed, it is off by a multiple of TIME_T_MAX -
+   TIME_T_MIN + 1.  So ignore any component of the difference
+   that is bounded by a small value.  */
 
       /* Approximate log base 2 of the number of time units per
-	 biennium.  A biennium is 2 years; use this unit instead of
-	 years to avoid integer overflow.  For example, 2 average
-	 Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,
-	 which is 63113904 seconds, and rint (log2 (63113904)) is
-	 26.  */
+   biennium.  A biennium is 2 years; use this unit instead of
+   years to avoid integer overflow.  For example, 2 average
+   Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,
+   which is 63113904 seconds, and rint (log2 (63113904)) is
+   26.  */
       int ALOG2_SECONDS_PER_BIENNIUM = 26;
       int ALOG2_MINUTES_PER_BIENNIUM = 20;
       int ALOG2_HOURS_PER_BIENNIUM = 14;
@@ -356,119 +434,117 @@ __mktime_internal (struct tm *tp,
       int LOG2_YEARS_PER_BIENNIUM = 1;
 
       int approx_requested_biennia =
-	(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)
-	 - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)
-	 + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)
-	 + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)
-	 + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)
-	 + (LEAP_SECONDS_POSSIBLE
-	    ? 0
-	    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));
+  (SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)
+   - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)
+   + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)
+   + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)
+   + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)
+   + (LEAP_SECONDS_POSSIBLE
+      ? 0
+      : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));
 
       int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);
       int diff = approx_biennia - approx_requested_biennia;
-      int abs_diff = diff < 0 ? - diff : diff;
+      int approx_abs_diff = diff < 0 ? -1 - diff : diff;
 
-      /* IRIX 4.0.5 cc miscaculates TIME_T_MIN / 3: it erroneously
-	 gives a positive value of 715827882.  Setting a variable
-	 first then doing math on it seems to work.
-	 (ghazi@caip.rutgers.edu) */
+      /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously
+   gives a positive value of 715827882.  Setting a variable
+   first then doing math on it seems to work.
+   (ghazi@caip.rutgers.edu) */
       time_t time_t_max = TIME_T_MAX;
       time_t time_t_min = TIME_T_MIN;
       time_t overflow_threshold =
-	(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;
-
-      if (overflow_threshold < abs_diff)
-	{
-	  /* Overflow occurred.  Try repairing it; this might work if
-	     the time zone offset is enough to undo the overflow.  */
-	  time_t repaired_t0 = -1 - t0;
-	  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);
-	  diff = approx_biennia - approx_requested_biennia;
-	  abs_diff = diff < 0 ? - diff : diff;
-	  if (overflow_threshold < abs_diff)
-	    return -1;
-	  guessed_offset += repaired_t0 - t0;
-	  t0 = repaired_t0;
-	}
+  (time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;
+
+      if (overflow_threshold < approx_abs_diff)
+  {
+    /* Overflow occurred.  Try repairing it; this might work if
+       the time zone offset is enough to undo the overflow.  */
+    time_t repaired_t0 = -1 - t0;
+    approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);
+    diff = approx_biennia - approx_requested_biennia;
+    approx_abs_diff = diff < 0 ? -1 - diff : diff;
+    if (overflow_threshold < approx_abs_diff)
+      return -1;
+    guessed_offset += repaired_t0 - t0;
+    t0 = repaired_t0;
+  }
     }
 
   /* Repeatedly use the error to improve the guess.  */
 
   for (t = t1 = t2 = t0, dst2 = 0;
        (gt = guess_time_tm (year, yday, hour, min, sec, &t,
-			    ranged_convert (convert, &t, &tm)),
-	t != gt);
+          ranged_convert (convert, &t, &tm)),
+  t != gt);
        t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)
     if (t == t1 && t != t2
-	&& (tm.tm_isdst < 0
-	    || (isdst < 0
-		? dst2 <= (tm.tm_isdst != 0)
-		: (isdst != 0) != (tm.tm_isdst != 0))))
+  && (tm.tm_isdst < 0
+      || (isdst < 0
+    ? dst2 <= (tm.tm_isdst != 0)
+    : (isdst != 0) != (tm.tm_isdst != 0))))
       /* We can't possibly find a match, as we are oscillating
-	 between two values.  The requested time probably falls
-	 within a spring-forward gap of size GT - T.  Follow the common
-	 practice in this case, which is to return a time that is GT - T
-	 away from the requested time, preferring a time whose
-	 tm_isdst differs from the requested value.  (If no tm_isdst
-	 was requested and only one of the two values has a nonzero
-	 tm_isdst, prefer that value.)  In practice, this is more
-	 useful than returning -1.  */
+   between two values.  The requested time probably falls
+   within a spring-forward gap of size GT - T.  Follow the common
+   practice in this case, which is to return a time that is GT - T
+   away from the requested time, preferring a time whose
+   tm_isdst differs from the requested value.  (If no tm_isdst
+   was requested and only one of the two values has a nonzero
+   tm_isdst, prefer that value.)  In practice, this is more
+   useful than returning -1.  */
       goto offset_found;
     else if (--remaining_probes == 0)
       return -1;
 
   /* We have a match.  Check whether tm.tm_isdst has the requested
      value, if any.  */
-  if (isdst != tm.tm_isdst && 0 <= isdst && 0 <= tm.tm_isdst)
+  if (isdst_differ (isdst, tm.tm_isdst))
     {
       /* tm.tm_isdst has the wrong value.  Look for a neighboring
-	 time with the right value, and use its UTC offset.
+   time with the right value, and use its UTC offset.
 
-	 Heuristic: probe the adjacent timestamps in both directions,
-	 looking for the desired isdst.  This should work for all real
-	 time zone histories in the tz database.  */
+   Heuristic: probe the adjacent timestamps in both directions,
+   looking for the desired isdst.  This should work for all real
+   time zone histories in the tz database.  */
 
       /* Distance between probes when looking for a DST boundary.  In
-	 tzdata2003a, the shortest period of DST is 601200 seconds
-	 (e.g., America/Recife starting 2000-10-08 01:00), and the
-	 shortest period of non-DST surrounded by DST is 694800
-	 seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the
-	 minimum of these two values, so we don't miss these short
-	 periods when probing.  */
+   tzdata2003a, the shortest period of DST is 601200 seconds
+   (e.g., America/Recife starting 2000-10-08 01:00), and the
+   shortest period of non-DST surrounded by DST is 694800
+   seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the
+   minimum of these two values, so we don't miss these short
+   periods when probing.  */
       int stride = 601200;
 
       /* The longest period of DST in tzdata2003a is 536454000 seconds
-	 (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest
-	 period of non-DST is much longer, but it makes no real sense
-	 to search for more than a year of non-DST, so use the DST
-	 max.  */
+   (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest
+   period of non-DST is much longer, but it makes no real sense
+   to search for more than a year of non-DST, so use the DST
+   max.  */
       int duration_max = 536454000;
 
       /* Search in both directions, so the maximum distance is half
-	 the duration; add the stride to avoid off-by-1 problems.  */
+   the duration; add the stride to avoid off-by-1 problems.  */
       int delta_bound = duration_max / 2 + stride;
 
       int delta, direction;
 
       for (delta = stride; delta < delta_bound; delta += stride)
-	for (direction = -1; direction <= 1; direction += 2)
-	  {
-	    time_t ot = t + delta * direction;
-	    if ((ot < t) == (direction < 0))
-	      {
-		struct tm otm;
-		ranged_convert (convert, &ot, &otm);
-		if (otm.tm_isdst == isdst)
-		  {
-		    /* We found the desired tm_isdst.
-		       Extrapolate back to the desired time.  */
-		    t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);
-		    ranged_convert (convert, &t, &tm);
-		    goto offset_found;
-		  }
-	      }
-	  }
+  for (direction = -1; direction <= 1; direction += 2)
+    if (time_t_int_add_ok (t, delta * direction))
+      {
+        time_t ot = t + delta * direction;
+        struct tm otm;
+        ranged_convert (convert, &ot, &otm);
+        if (! isdst_differ (isdst, otm.tm_isdst))
+    {
+      /* We found the desired tm_isdst.
+         Extrapolate back to the desired time.  */
+      t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);
+      ranged_convert (convert, &t, &tm);
+      goto offset_found;
+    }
+      }
     }
 
  offset_found:
@@ -477,14 +553,16 @@ __mktime_internal (struct tm *tp,
   if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)
     {
       /* Adjust time to reflect the tm_sec requested, not the normalized value.
-	 Also, repair any damage from a false match due to a leap second.  */
+   Also, repair any damage from a false match due to a leap second.  */
       int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;
+      if (! time_t_int_add_ok (t, sec_requested))
+  return -1;
       t1 = t + sec_requested;
+      if (! time_t_int_add_ok (t1, sec_adjustment))
+  return -1;
       t2 = t1 + sec_adjustment;
-      if (((t1 < t) != (sec_requested < 0))
-	  | ((t2 < t1) != (sec_adjustment < 0))
-	  | ! convert (&t2, &tm))
-	return -1;
+      if (! convert (&t2, &tm))
+  return -1;
       t = t2;
     }
 
@@ -505,7 +583,7 @@ mktime (struct tm *tp)
 {
 #ifdef _LIBC
   /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
-     time zone names contained in the external variable `tzname' shall
+     time zone names contained in the external variable 'tzname' shall
      be set as if the tzset() function had been called.  */
   __tzset ();
 #endif
@@ -522,19 +600,19 @@ libc_hidden_def (mktime)
 libc_hidden_weak (timelocal)
 #endif
 
-#if DEBUG
+#if defined DEBUG && DEBUG
 
 static int
 not_equal_tm (const struct tm *a, const struct tm *b)
 {
   return ((a->tm_sec ^ b->tm_sec)
-	  | (a->tm_min ^ b->tm_min)
-	  | (a->tm_hour ^ b->tm_hour)
-	  | (a->tm_mday ^ b->tm_mday)
-	  | (a->tm_mon ^ b->tm_mon)
-	  | (a->tm_year ^ b->tm_year)
-	  | (a->tm_yday ^ b->tm_yday)
-	  | (a->tm_isdst ^ b->tm_isdst));
+    | (a->tm_min ^ b->tm_min)
+    | (a->tm_hour ^ b->tm_hour)
+    | (a->tm_mday ^ b->tm_mday)
+    | (a->tm_mon ^ b->tm_mon)
+    | (a->tm_year ^ b->tm_year)
+    | (a->tm_yday ^ b->tm_yday)
+    | isdst_differ (a->tm_isdst, b->tm_isdst));
 }
 
 static void
@@ -542,9 +620,9 @@ print_tm (const struct tm *tp)
 {
   if (tp)
     printf ("%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d",
-	    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
-	    tp->tm_hour, tp->tm_min, tp->tm_sec,
-	    tp->tm_yday, tp->tm_wday, tp->tm_isdst);
+      tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
+      tp->tm_hour, tp->tm_min, tp->tm_sec,
+      tp->tm_yday, tp->tm_wday, tp->tm_isdst);
   else
     printf ("0");
 }
@@ -576,11 +654,11 @@ main (int argc, char **argv)
 
   if ((argc == 3 || argc == 4)
       && (sscanf (argv[1], "%d-%d-%d%c",
-		  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)
-	  == 3)
+      &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)
+    == 3)
       && (sscanf (argv[2], "%d:%d:%d%c",
-		  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)
-	  == 3))
+      &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)
+    == 3))
     {
       tm.tm_year -= TM_YEAR_BASE;
       tm.tm_mon--;
@@ -589,10 +667,10 @@ main (int argc, char **argv)
       tl = mktime (&tmk);
       lt = localtime (&tl);
       if (lt)
-	{
-	  tml = *lt;
-	  lt = &tml;
-	}
+  {
+    tml = *lt;
+    lt = &tml;
+  }
       printf ("mktime returns %ld == ", (long int) tl);
       print_tm (&tmk);
       printf ("\n");
@@ -605,51 +683,51 @@ main (int argc, char **argv)
       time_t to = atol (argv[3]);
 
       if (argc == 4)
-	for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
-	  {
-	    lt = localtime (&tl);
-	    if (lt)
-	      {
-		tmk = tml = *lt;
-		tk = mktime (&tmk);
-		status |= check_result (tk, tmk, tl, &tml);
-	      }
-	    else
-	      {
-		printf ("localtime (%ld) yields 0\n", (long int) tl);
-		status = 1;
-	      }
-	    tl1 = tl + by;
-	    if ((tl1 < tl) != (by < 0))
-	      break;
-	  }
+  for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
+    {
+      lt = localtime (&tl);
+      if (lt)
+        {
+    tmk = tml = *lt;
+    tk = mktime (&tmk);
+    status |= check_result (tk, tmk, tl, &tml);
+        }
       else
-	for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
-	  {
-	    /* Null benchmark.  */
-	    lt = localtime (&tl);
-	    if (lt)
-	      {
-		tmk = tml = *lt;
-		tk = tl;
-		status |= check_result (tk, tmk, tl, &tml);
-	      }
-	    else
-	      {
-		printf ("localtime (%ld) yields 0\n", (long int) tl);
-		status = 1;
-	      }
-	    tl1 = tl + by;
-	    if ((tl1 < tl) != (by < 0))
-	      break;
-	  }
+        {
+    printf ("localtime (%ld) yields 0\n", (long int) tl);
+    status = 1;
+        }
+      tl1 = tl + by;
+      if ((tl1 < tl) != (by < 0))
+        break;
+    }
+      else
+  for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
+    {
+      /* Null benchmark.  */
+      lt = localtime (&tl);
+      if (lt)
+        {
+    tmk = tml = *lt;
+    tk = tl;
+    status |= check_result (tk, tmk, tl, &tml);
+        }
+      else
+        {
+    printf ("localtime (%ld) yields 0\n", (long int) tl);
+    status = 1;
+        }
+      tl1 = tl + by;
+      if ((tl1 < tl) != (by < 0))
+        break;
+    }
     }
   else
     printf ("Usage:\
 \t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\n\
 \t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\n\
 \t%s FROM BY TO - # Do not test those values (for benchmark).\n",
-	    argv[0], argv[0], argv[0]);
+      argv[0], argv[0], argv[0]);
 
   return status;
 }
@@ -658,6 +736,6 @@ main (int argc, char **argv)
 
 /*
 Local Variables:
-compile-command: "gcc -DDEBUG -Wall -W -O -g mktime.c -o mktime"
+compile-command: "gcc -DDEBUG -I. -Wall -W -O2 -g mktime.c -o mktime"
 End:
-*/
+*/
\ No newline at end of file
diff --git a/gnulib/lib/mountlist.c b/gnulib/lib/mountlist.c
--- a/gnulib/lib/mountlist.c
+++ b/gnulib/lib/mountlist.c
@@ -89,7 +89,7 @@
 # include <dirent.h>
 #endif
 
-#ifdef MOUNTED_FREAD		/* SVR2.  */
+#if !defined __native_client__ && defined MOUNTED_FREAD		/* SVR2.  */
 # include <mnttab.h>
 #endif
 
@@ -103,9 +103,7 @@
 # include <mntent.h>
 #endif
 
-#ifdef MOUNTED_GETMNTENT2	/* SVR4.  */
-# include <sys/mnttab.h>
-#endif
+
 
 #ifdef MOUNTED_VMOUNT		/* AIX.  */
 # include <fshelp.h>
@@ -634,10 +632,12 @@ read_file_system_list (bool need_fs_type)
   }
 #endif /* MOUNTED_GETFSSTAT */
 
-#if defined MOUNTED_FREAD || defined MOUNTED_FREAD_FSTYP /* SVR[23].  */
+/* disable mount logic in nacl */
+#if !defined __native_client__ && (defined MOUNTED_FREAD \
+  || defined MOUNTED_FREAD_FSTYP) /* SVR[23].  */
   {
     struct mnttab mnt;
-    char *table = "/etc/mnttab";
+    char *table = "/etc/mtab";
     FILE *fp;
 
     fp = fopen (table, "r");
@@ -716,7 +716,8 @@ read_file_system_list (bool need_fs_type)
   }
 #endif
 
-#ifdef MOUNTED_GETMNTENT2	/* SVR4.  */
+/* disable mount logic in nacl */
+#if !defined __native_client__ && defined MOUNTED_GETMNTENT2	/* SVR4.  */
   {
     struct mnttab mnt;
     char *table = MNTTAB;
diff --git a/gnulib/lib/stdint.in.h b/gnulib/lib/stdint.in.h
--- a/gnulib/lib/stdint.in.h
+++ b/gnulib/lib/stdint.in.h
@@ -61,7 +61,7 @@
    MacOS X 10.4.6 <sys/types.h> includes <stdint.h> (which is us), but
    relies on the system <stdint.h> definitions, so include
    <sys/types.h> after @NEXT_STDINT_H@.  */
-#if @HAVE_SYS_TYPES_H@ && ! defined _AIX
+#if @HAVE_SYS_TYPES_H@ && ! defined _AIX && !defined __native_client__
 # include <sys/types.h>
 #endif
 
@@ -79,7 +79,7 @@
 # include <sys/inttypes.h>
 #endif
 
-#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__
+#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__ && !defined __native_client__
   /* Linux libc4 >= 4.6.7 and libc5 have a <sys/bitypes.h> that defines
      int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is
      included by <sys/types.h>.  */
diff --git a/gnulib/lib/stdio.in.h b/gnulib/lib/stdio.in.h
--- a/gnulib/lib/stdio.in.h
+++ b/gnulib/lib/stdio.in.h
@@ -35,10 +35,12 @@
 #include <stdarg.h>
 #include <stddef.h>
 
-#if (@GNULIB_FSEEKO@ && @REPLACE_FSEEKO@) \
+#if ((@GNULIB_FSEEKO@ && @REPLACE_FSEEKO@) \
   || (@GNULIB_FTELLO@ && @REPLACE_FTELLO@) \
   || (@GNULIB_GETDELIM@ && !@HAVE_DECL_GETDELIM@) \
-  || (@GNULIB_GETLINE@ && (!@HAVE_DECL_GETLINE@ || @REPLACE_GETLINE@))
+  || (@GNULIB_GETLINE@ && (!@HAVE_DECL_GETLINE@ || @REPLACE_GETLINE@))) \
+  && !defined __native_client_
+
 /* Get off_t and ssize_t.  */
 # include <sys/types.h>
 #endif
@@ -238,7 +240,7 @@ extern FILE * freopen (const char *filename, const char *mode, FILE *stream);
     freopen (f, m, s))
 #endif
 
-#if @GNULIB_FSEEKO@
+#if !defined __native_client__ && @GNULIB_FSEEKO@
 # if @REPLACE_FSEEKO@
 /* Provide fseek, fseeko functions that are aware of a preceding
    fflush(), and which detect pipes.  */
diff --git a/gnulib/lib/wchar.in.h b/gnulib/lib/wchar.in.h
--- a/gnulib/lib/wchar.in.h
+++ b/gnulib/lib/wchar.in.h
@@ -26,7 +26,12 @@
  * the declaration of wcwidth().
  */
 
-#ifndef _GL_WCHAR_H
+/* when we set toolchain as glibc(newlib works fine),
+  somehow _GL_WCHAR_H is 1,
+  the following code won't get included, however we still 
+  need the code to include the origianl wchar.h
+  in the nalc include folder*/
+#if !defined _GL_WCHAR_H || defined __native_client__
 
 /* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
    <wchar.h>.
diff --git a/gnulib/m4/gnulib-comp.m4 b/gnulib/m4/gnulib-comp.m4
--- a/gnulib/m4/gnulib-comp.m4
+++ b/gnulib/m4/gnulib-comp.m4
@@ -470,6 +470,7 @@ AC_DEFUN([gl_FILE_LIST], [
   lib/memset.c
   lib/mkdirat.c
   lib/mktime.c
+  lib/mktime-internal.h
   lib/modechange.c
   lib/modechange.h
   lib/mountlist.c
diff --git a/gnulib/m4/mktime.m4 b/gnulib/m4/mktime.m4
--- a/gnulib/m4/mktime.m4
+++ b/gnulib/m4/mktime.m4
@@ -220,6 +220,26 @@ AC_DEFUN([gl_FUNC_MKTIME],
   fi
 ])
 
+########## add mktime-internal.h ###################################
+##########(copied this part from latest gnulib) ####################
+########## see more details in the ports/findutils/README ##########
+AC_DEFUN([gl_FUNC_MKTIME_INTERNAL], [
+  AC_REQUIRE([gl_FUNC_MKTIME])
+  if test $REPLACE_MKTIME = 0; then
+    dnl BeOS has __mktime_internal in libc, but other platforms don't.
+    AC_CHECK_FUNC([__mktime_internal],
+      [AC_DEFINE([mktime_internal], [__mktime_internal],
+         [Define to the real name of the mktime_internal function.])
+      ],
+      [dnl mktime works but it doesn't export __mktime_internal,
+       dnl so we need to substitute our own mktime implementation.
+       REPLACE_MKTIME=1
+       AC_LIBOBJ([mktime])
+       gl_PREREQ_MKTIME
+      ])
+  fi
+])
+
 # Prerequisites of lib/mktime.c.
 AC_DEFUN([gl_PREREQ_MKTIME],
 [
diff --git a/lib/Makefile.in b/lib/Makefile.in
--- a/lib/Makefile.in
+++ b/lib/Makefile.in
@@ -197,7 +197,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/build-aux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
-AR = ar
+AR ?= ar
 ARFLAGS = cru
 libfind_a_AR = $(AR) $(ARFLAGS)
 am_libfind_a_OBJECTS = gnulib-version.$(OBJEXT) \
diff --git a/lib/buildcmd.c b/lib/buildcmd.c
--- a/lib/buildcmd.c
+++ b/lib/buildcmd.c
@@ -103,7 +103,9 @@
 #define ARG_MAX NCARGS
 #endif
 
-
+#ifndef _POSIX_ARG_MAX
+#define _POSIX_ARG_MAX 4096
+#endif
 
 #include <xalloc.h>
 #include <error.h>
diff --git a/tests/Makefile.in b/tests/Makefile.in
--- a/tests/Makefile.in
+++ b/tests/Makefile.in
@@ -253,7 +253,7 @@ mkinstalldirs = $(SHELL) $(top_srcdir)/build-aux/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
-AR = ar
+AR ?= ar
 ARFLAGS = cru
 libtests_a_AR = $(AR) $(ARFLAGS)
 am__DEPENDENCIES_1 =
diff --git a/xargs/xargs.c b/xargs/xargs.c
--- a/xargs/xargs.c
+++ b/xargs/xargs.c
@@ -51,6 +51,7 @@
 #define ISSPACE(c) (ISBLANK (c) || (c) == '\n' || (c) == '\r' \
 		    || (c) == '\f' || (c) == '\v')
 
+#include <spawn.h>
 #include <sys/types.h>
 #include <stdio.h>
 #include <errno.h>
@@ -1128,13 +1129,13 @@ xargs_do_exec (const struct buildcmd_control *ctl, struct buildcmd_state *state)
 
       /* If we run out of processes, wait for a child to return and
          try again.  */
-      while ((child = fork ()) < 0 && errno == EAGAIN && procs_executing)
+      while ((child = vfork ()) < 0 && errno == EAGAIN && procs_executing)
 	wait_for_proc (false, 1u);
 
       switch (child)
 	{
 	case -1:
-	  error (1, errno, _("cannot fork"));
+	  error (1, errno, _("cannot vfork"));
 
 	case 0:		/* Child.  */
 	  prep_child_for_exec();
